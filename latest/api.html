<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TaylorSeries.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorSeries.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="background.html">Background</a></li><li><a class="toctext" href="userguide.html">User guide</a></li><li><a class="toctext" href="examples.html">Examples</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-and-methods-1">Functions and methods</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries" href="#TaylorSeries"><code>TaylorSeries</code></a> — <span class="docstring-category">Module</span>.</div><div><pre><code class="language-none">TaylorSeries</code></pre><p>A Julia package for Taylor expansions in one or more independent variables.</p><p>The basic constructors are <a href="api.html#TaylorSeries.Taylor1"><code>Taylor1</code></a> and <a href="api.html#TaylorSeries.TaylorN"><code>TaylorN</code></a>; see also <a href="api.html#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/TaylorSeries.jl#L10-L18">source</a><br/></section><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.Taylor1" href="#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Taylor1{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in one independent variable.</p><p><strong>Fields:</strong></p><ul><li><p><code>coeffs :: Array{T,1}</code> Expansion coefficients; the <span>$i$</span>-th   component is the coefficient of degree <span>$i-1$</span> of the expansion.</p></li><li><p><code>order  :: Int64</code> Maximum order (degree) of the polynomial.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/constructors.jl#L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial" href="#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HomogeneousPolynomial{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for homogenous polynomials in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><p><code>coeffs  :: Array{T,1}</code> Expansion coefficients of the homogeneous</p></li></ul><p>polynomial; the <span>$i$</span>-th component is related to a monomial, where the degrees of the independent variables are specified by <code>coeff_table[order+1][i]</code>.</p><ul><li><p><code>order   :: Int</code> order (degree) of the homogenous polynomial.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/constructors.jl#L73">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.TaylorN" href="#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TaylorN{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><p><code>coeffs  :: Array{HomogeneousPolynomial{T},1}</code> Vector containing the</p></li></ul><p><code>HomogeneousPolynomial</code> entries. The <span>$i$</span>-th component corresponds to the homogeneous polynomial of degree <span>$i-1$</span>.</p><ul><li><p><code>order   :: Int</code>  maximum order of the polynomial expansion.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/constructors.jl#L129">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.AbstractSeries" href="#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSeries{T&lt;:Number} &lt;: Number</code></pre><p>Parameterized abstract type for <a href="api.html#TaylorSeries.Taylor1"><code>Taylor1</code></a>, <a href="api.html#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a> and <a href="api.html#TaylorSeries.TaylorN"><code>TaylorN</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/constructors.jl#L9-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.ParamsTaylorN" href="#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ParamsTaylorN</code></pre><p>DataType holding the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>order          :: Int</code>  Order (degree) of the polynomials</p></li><li><p><code>num_vars       :: Int</code>  Number of variables</p></li><li><p><code>variable_names :: Array{String,1}</code> Name of the variables</p></li></ul><p>These parameters can be changed using <code>set_params_TaylorN(order, numVars)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/parameters.jl#L6">source</a><br/></section><h2><a class="nav-anchor" id="Functions-and-methods-1" href="#Functions-and-methods-1">Functions and methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.Taylor1-Tuple{Type{Float64},Int64}" href="#TaylorSeries.Taylor1-Tuple{Type{Float64},Int64}"><code>TaylorSeries.Taylor1</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Taylor1([T::Type=Float64], [order::Int=1])</code></pre><p>Shortcut to define the independent variable of a <code>Taylor1{T}</code> polynomial of given <code>order</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; Taylor1(16)
 1.0 t + 𝒪(t¹⁷)

julia&gt; Taylor1(Rational{Int}, 4)
 1//1 t + 𝒪(t⁵)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/constructors.jl#L54">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial-Tuple{Type{T&lt;:Number},Int64}" href="#TaylorSeries.HomogeneousPolynomial-Tuple{Type{T&lt;:Number},Int64}"><code>TaylorSeries.HomogeneousPolynomial</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">HomogeneousPolynomial([T::Type=Float64], nv::Int])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>HomogeneousPolynomial{T}</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; HomogeneousPolynomial(1)
 1.0 x₁

julia&gt; HomogeneousPolynomial(Rational{Int}, 2)
 1//1 x₂</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/constructors.jl#L104-L117">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.TaylorN-Tuple{Type{T&lt;:Number},Int64}" href="#TaylorSeries.TaylorN-Tuple{Type{T&lt;:Number},Int64}"><code>TaylorSeries.TaylorN</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">TaylorN([T::Type=Float64], nv::Int; [order::Int=get_order()])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>TaylorN{T}</code> variable as a polynomial. The order is defined through the keyword parameter <code>order</code>, whose default corresponds to <code>get_order()</code>. The default of type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; TaylorN(1)
 1.0 x₁ + 𝒪(‖x‖⁷)

julia&gt; TaylorN(Rational{Int},2)
 1//1 x₂ + 𝒪(‖x‖⁷)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/constructors.jl#L168-L183">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.set_variables" href="#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">set_variables([T::Type], names::String; [order=get_order(), numvars=-1])</code></pre><p>Return a <code>TaylorN{T}</code> vector with each entry representing an independent variable. <code>names</code> defines the output for each variable (separated by a space). The default type <code>T</code> is <code>Float64</code>, and the default for <code>order</code> is the one defined globally. Changing the <code>order</code> or <code>numvars</code> resets the hash_tables.</p><p>If <code>numvars</code> is not specified, it is inferred from <code>names</code>. If only one variable name is defined and <code>numvars&gt;1</code>, it uses this name with subscripts for the different variables.</p><pre><code class="language-julia">julia&gt; set_variables(Int, &quot;x y z&quot;, order=4)
3-element Array{TaylorSeries.TaylorN{Int64},1}:
  1 x + 𝒪(‖x‖⁵)
  1 y + 𝒪(‖x‖⁵)
  1 z + 𝒪(‖x‖⁵)

julia&gt; set_variables(&quot;α&quot;, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 α₁ + 𝒪(‖x‖⁵)
  1.0 α₂ + 𝒪(‖x‖⁵)

julia&gt; set_variables(&quot;x&quot;, order=6, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 x₁ + 𝒪(‖x‖⁷)
  1.0 x₂ + 𝒪(‖x‖⁷)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/parameters.jl#L38-L68">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.show_params_TaylorN" href="#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">show_params_TaylorN()</code></pre><p>Display the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code> types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/parameters.jl#L114-L118">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.get_coeff" href="#TaylorSeries.get_coeff"><code>TaylorSeries.get_coeff</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_coeff(a, n)</code></pre><p>Return the coefficient of order <code>n::Int</code> of a <code>a::Taylor1</code> polynomial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L68-L72">source</a><br/><div><pre><code class="language-none">get_coeff(a, v)</code></pre><p>Return the coefficient of <code>a::HomogeneousPolynomial</code>, specified by <code>v::Array{Int,1}</code> which has the indices of the specific monomial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L86-L91">source</a><br/><div><pre><code class="language-none">get_coeff(a, v)</code></pre><p>Return the coefficient of <code>a::TaylorN</code>, specified by <code>v::Array{Int,1}</code> which has the indices of the specific monomial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L114-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.evaluate" href="#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">evaluate(a, [dx])</code></pre><p>Evaluate a <code>Taylor1</code> polynomial using Horner&#39;s rule (hand coded). If <code>dx</code> is ommitted, its value is considered as zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/evaluate.jl#L10-L15">source</a><br/><div><pre><code class="language-none">evaluate(x, δt)</code></pre><p>Evaluates each element of <code>x::Array{Taylor1{T},1}</code>, representing the dependent variables of an ODE, at <em>time</em> δt.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/evaluate.jl#L33">source</a><br/><div><pre><code class="language-none">evaluate(a, x)</code></pre><p>Substitute <code>x::Taylor1</code> as independent variable in a <code>a::Taylor1</code> polynomial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/evaluate.jl#L74-L78">source</a><br/><div><pre><code class="language-none">evaluate(a, vals)</code></pre><p>Evaluate a <code>HomogeneousPolynomial</code> polynomial at <code>vals</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/evaluate.jl#L112-L116">source</a><br/><div><pre><code class="language-none">evaluate(a, [vals])</code></pre><p>Evaluate the <code>TaylorN</code> polynomial <code>a</code> at <code>vals</code>. If <code>vals</code> is ommitted, it&#39;s evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/evaluate.jl#L139-L144">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.evaluate!" href="#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">evaluate!(x, δt, x0)</code></pre><p>Evaluates each element of <code>x::Array{Taylor1{T},1}</code>, representing the Taylor expansion for the dependent variables of an ODE at <em>time</em> <code>δt</code>. It updates the vector <code>x0</code> with the computed values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/evaluate.jl#L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.derivative" href="#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">derivative(a)</code></pre><p>Return the <code>Taylor1</code> polynomial of the differential of <code>a::Taylor1</code>. The last coefficient is set to zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L10-L15">source</a><br/><div><pre><code class="language-none">derivative(n, a)</code></pre><p>Return the value of the <code>n</code>-th derivative of the polynomial <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L25-L29">source</a><br/><div><pre><code class="language-none">derivative(a, r)</code></pre><p>Partial differentiation of <code>a::HomogeneousPolynomial</code> series with respect to the <code>r</code>-th variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L56-L61">source</a><br/><div><pre><code class="language-none">derivative(a, [r=1])</code></pre><p>Partial differentiation of <code>a::TaylorN</code> series with respect to the <code>r</code>-th variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L85-L90">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.integrate" href="#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">integrate(a, [x])</code></pre><p>Return the integral of <code>a::Taylor1</code>. The constant of integration (0-th order coefficient) is set to <code>x</code>, which is zero if ommitted.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L36-L41">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.gradient" href="#Base.LinAlg.gradient"><code>Base.LinAlg.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    gradient(f)
    ∇(f)</code></pre><p>Compute the gradient of the polynomial <code>f::TaylorN</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L104-L111">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.jacobian" href="#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    jacobian(vf)
    jacobian(vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L123-L131">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.jacobian!" href="#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    jacobian!(jac, vf)
    jacobian!(jac, vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials evaluated at the vector <code>vals</code>, and write results to <code>jac</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L164-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.hessian" href="#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    hessian(f)
    hessian(f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L197-L206">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.hessian!" href="#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    hessian!(hes, f)
    hessian!(hes, f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>, and write results to <code>hes</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/calculus.jl#L211-L220">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.inverse" href="#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">inverse(f)</code></pre><p>Return the Taylor expansion of <span>$f^{-1}(t)$</span>, of order <code>N = f.order</code>, for <code>f::Taylor1</code> polynomial if the first coefficient of <code>f</code> is zero. Otherwise, an <code>ArgumentError</code> is thrown.</p><p>The algorithm implements Lagrange inversion at <span>$t=0$</span> if <span>$f(0)=0$</span>:</p><div>\[\begin{equation*}
f^{-1}(t) = \sum_{n=1}^{N} \frac{t^n}{n!} \left.
    \frac{{\rm d}^{n-1}}{{\rm d} z^{n-1}}\left(\frac{z}{f(z)}\right)^n
    \right\vert_{z=0}.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L322">source</a><br/></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.generate_tables" href="#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">generate_tables(num_vars, order)</code></pre><p>Return the hash tables <code>coeff_table</code>, <code>index_table</code>, <code>size_table</code> and <code>pos_table</code>. Internally, these are treated as <code>const</code>.</p><p><strong>Hash tables</strong></p><pre><code class="language-none">coeff_table :: Array{Array{Array{Int64,1},1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector with the vectors of all the possible combinations of monomials of a <code>HomogeneousPolynomial</code> of order <span>$i$</span>.</p><pre><code class="language-none">index_table :: Array{Array{Int64,1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector of (hashed) indices that represent the distinct monomials of a <code>HomogeneousPolynomial</code> of order (degree) <span>$i$</span>.</p><pre><code class="language-none">size_table :: Array{Int64,1}</code></pre><p>The <span>$i+1$</span>-th component contains the number of distinct monomials of the <code>HomogeneousPolynomial</code> of order <span>$i$</span>, equivalent to <code>length(coeff_table[i])</code>.</p><pre><code class="language-none">pos_table :: Array{Dict{Int64,Int64},1}</code></pre><p>The <span>$i+1$</span>-th component maps the hash index to the (lexicographic) position of the corresponding monomial in <code>coeffs_table</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/hash_tables.jl#L5">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.generate_index_vectors" href="#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">generate_index_vectors(num_vars, degree)</code></pre><p>Return a vector of index vectors with <code>num_vars</code> (number of variables) and degree.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/hash_tables.jl#L44-L49">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.in_base" href="#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">in_base(order, v)</code></pre><p>Convert vector <code>v</code> of non-negative integers to base <code>order+1</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/hash_tables.jl#L84-L88">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.make_inverse_dict" href="#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">make_inverse_dict(v)</code></pre><p>Return a Dict with the enumeration of <code>v</code>: the elements of <code>v</code> point to the corresponding index.</p><p>It is used to construct <code>pos_table</code> from <code>index_table</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/hash_tables.jl#L72-L79">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.order_posTb" href="#TaylorSeries.order_posTb"><code>TaylorSeries.order_posTb</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">order_posTb(order, nv, ord)</code></pre><p>Return a vector with the positions, in a <code>HomogeneousPolynomial</code> of order <code>order</code>, where the variable <code>nv</code> has order <code>ord</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L198-L203">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.resize_coeffs1!" href="#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">resize_coeffs1!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than <code>order+1</code>, it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L11-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.resize_coeffsHP!" href="#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">resize_coeffsHP!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than the number of coefficients correspondinf to <code>order</code> (given by <code>size_table[order+1]</code>), it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L26-L32">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.zero_korder" href="#TaylorSeries.zero_korder"><code>TaylorSeries.zero_korder</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">zero_korder(a)</code></pre><p>For <code>a::Taylor1</code> returns <code>zero(a[1])</code> while for <code>a::TaylorN</code> returns a zero of a k-th order <code>HomogeneousPolynomial</code> of proper type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L183-L188">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.constant_term" href="#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">constant_term(a)</code></pre><p>Return the constant value (zero order coefficient) for <code>Taylor1</code> and <code>TaylorN</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/auxiliary.jl#L217-L222">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.mul!" href="#TaylorSeries.mul!"><code>TaylorSeries.mul!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mul!(c, a, b, k::Int) --&gt; nothing</code></pre><p>Update the <code>k</code>-th expansion coefficient <code>c[k+1]</code> of <code>c = a * b</code>, where all <code>c</code>, <code>a</code>, and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k = \sum_{j=0}^k a_j b_{k-j}.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/arithmetic.jl#L276">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.mul!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}" href="#TaylorSeries.mul!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mul!(c, a, b) --&gt; nothing</code></pre><p>Return <code>c = a*b</code> with no allocation; all arguments are <code>HomogeneousPolynomial</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/arithmetic.jl#L291-L296">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.div!" href="#TaylorSeries.div!"><code>TaylorSeries.div!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">div!(c, a, b, k::Int, ordfact::Int=0)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = a / b</code>, where all <code>c</code>, <code>a</code> and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k =  \frac{1}{b_0} \big(a_k - \sum_{j=0}^{k-1} c_j b_{k-j}\big).\]</div><p>For <code>Taylor1</code> polynomials, <code>ordfact</code> is the order of the factorized term of the denominator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/arithmetic.jl#L432">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.pow!" href="#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pow!(c, a, r::Real, k::Int, k0::Int=0)</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = a^r</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k = \frac{1}{k a_0} \sum_{j=0}^{k-1} \big(r(k-j) -j\big)a_{k-j} c_j.\]</div><p>For <code>Taylor1</code> polynomials, <code>k0</code> is the order of the first non-zero coefficient of <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/power.jl#L117">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.square" href="#TaylorSeries.square"><code>TaylorSeries.square</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">square(a::AbstractSeries) --&gt; typeof(a)</code></pre><p>Return <code>a^2</code>; see <a href="api.html#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/power.jl#L167-L171">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqr!" href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqr!(c, a, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = a^2</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
c_k &amp; = &amp; 2 \sum_{j=0}^{(k-1)/2} a_{k-j} a_j,
    \text{ if k is odd,} \\
c_k &amp; = &amp; 2 \sum_{j=0}^{(k-2)/2} a_{k-j} a_j + (a_{k/2})^2,
    \text{ if k is even. }
\end{eqnarray*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/power.jl#L196">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqr!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}" href="#TaylorSeries.sqr!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.sqr!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sqr!(c, a)</code></pre><p>Return <code>c = a*a</code> with no allocation; all parameters are <code>HomogeneousPolynomial</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/power.jl#L247-L252">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqrt!" href="#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqrt!(c, a, k::Int, k0::Int=0)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = sqrt(a)</code> for both<code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
c_k &amp;=&amp; \frac{1}{2 c_0} \big( a_k - 2 \sum_{j=0}^{(k-1)/2} c_{k-j}c_j\big),
    \text{ if $k$ is odd,} \\
c_k &amp;=&amp; \frac{1}{2 c_0} \big( a_k - 2 \sum_{j=0}^{(k-2)/2} c_{k-j}c_j\big)
    - (c_{k/2})^2, \text{ if $k$ is even.}
\end{eqnarray*}\]</div><p>For <code>Taylor1</code> polynomials, <code>k0</code> is the order of the first non-zero coefficient, which must be even.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/power.jl#L326">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.exp!" href="#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">exp!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = exp(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L364">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.log!" href="#TaylorSeries.log!"><code>TaylorSeries.log!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">log!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = log(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = \frac{1}{a_0} \big(a_k - \frac{1}{k} \sum_{j=0}^{k-1} j a_{k-j} c_j \big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L381">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sincos!" href="#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sincos!(s, c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sin(a)</code> and <code>c = cos(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
s_k &amp;=&amp;  \frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j ,\\
c_k &amp;=&amp; -\frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{eqnarray*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L398">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.tan!" href="#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tan!(c, a, p, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = c^2</code> and is passed as an argument for efficiency.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = a_k + \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L417">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.asin!" href="#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asin!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = asin(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = \frac{1}{ \sqrt{r_0} }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L435">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.acos!" href="#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acos!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = acos(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = - \frac{1}{ r_0 }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L452">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.atan!" href="#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atan!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = atan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = 1+a^2</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = \frac{1}{r_0}\big(a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j\big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L469">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sinhcosh!" href="#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sinhcosh!(s, c, a, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sinh(a)</code> and <code>c = cosh(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
s_k &amp;=&amp; \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j, \\
c_k &amp;=&amp; \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{eqnarray*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L485">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.tanh!" href="#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tanh!(c, a, p, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tanh(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = a^2</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = a_k - \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/functions.jl#L504">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_mul_B!" href="#Base.LinAlg.A_mul_B!"><code>Base.LinAlg.A_mul_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_B!(Y, A, B)</code></pre><p>Multiply A*B and save the result in Y.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/tree/2381ad4b8a0420f816d83e14aaa1c792919c34dd/src/arithmetic.jl#L477-L481">source</a><br/></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="api.html#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a></li><li><a href="api.html#TaylorSeries.HomogeneousPolynomial-Tuple{Type{T&lt;:Number},Int64}"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="api.html#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="api.html#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a></li><li><a href="api.html#TaylorSeries.Taylor1-Tuple{Type{Float64},Int64}"><code>TaylorSeries.Taylor1</code></a></li><li><a href="api.html#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a></li><li><a href="api.html#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a></li><li><a href="api.html#TaylorSeries.TaylorN-Tuple{Type{T&lt;:Number},Int64}"><code>TaylorSeries.TaylorN</code></a></li><li><a href="api.html#Base.LinAlg.A_mul_B!"><code>Base.LinAlg.A_mul_B!</code></a></li><li><a href="api.html#Base.LinAlg.gradient"><code>Base.LinAlg.gradient</code></a></li><li><a href="api.html#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a></li><li><a href="api.html#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a></li><li><a href="api.html#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a></li><li><a href="api.html#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a></li><li><a href="api.html#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a></li><li><a href="api.html#TaylorSeries.div!"><code>TaylorSeries.div!</code></a></li><li><a href="api.html#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a></li><li><a href="api.html#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a></li><li><a href="api.html#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a></li><li><a href="api.html#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a></li><li><a href="api.html#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a></li><li><a href="api.html#TaylorSeries.get_coeff"><code>TaylorSeries.get_coeff</code></a></li><li><a href="api.html#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a></li><li><a href="api.html#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a></li><li><a href="api.html#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a></li><li><a href="api.html#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a></li><li><a href="api.html#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a></li><li><a href="api.html#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a></li><li><a href="api.html#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a></li><li><a href="api.html#TaylorSeries.log!"><code>TaylorSeries.log!</code></a></li><li><a href="api.html#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a></li><li><a href="api.html#TaylorSeries.mul!"><code>TaylorSeries.mul!</code></a></li><li><a href="api.html#TaylorSeries.mul!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.mul!</code></a></li><li><a href="api.html#TaylorSeries.order_posTb"><code>TaylorSeries.order_posTb</code></a></li><li><a href="api.html#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a></li><li><a href="api.html#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a></li><li><a href="api.html#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a></li><li><a href="api.html#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a></li><li><a href="api.html#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a></li><li><a href="api.html#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a></li><li><a href="api.html#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a></li><li><a href="api.html#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a></li><li><a href="api.html#TaylorSeries.sqr!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.sqr!</code></a></li><li><a href="api.html#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a></li><li><a href="api.html#TaylorSeries.square"><code>TaylorSeries.square</code></a></li><li><a href="api.html#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a></li><li><a href="api.html#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a></li><li><a href="api.html#TaylorSeries.zero_korder"><code>TaylorSeries.zero_korder</code></a></li></ul><footer><hr/><a class="previous" href="examples.html"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
