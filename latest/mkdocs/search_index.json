{
    "docs": [
        {
            "location": "/", 
            "text": "TaylorSeries.jl\n\n\nA \nJulia\n package for Taylor expansions in one or more independent variables.\n\n\n\n\n\n\nAuthors\n\n\n\n\nLuis Benet\n, Instituto de Ciencias F\u00edsicas, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\nDavid P. Sanders\n, Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\n\n\n\n\nLicense\n\n\nTaylorSeries is licensed under the MIT \"Expat\" license; see \nLICENSE\n for the full license text.\n\n\n\n\nInstallation\n\n\nTaylorSeries.jl is a \nregistered package\n, and is simply installed by running\n\n\njulia\n Pkg.add(\nTaylorSeries\n)\n\n\n\n\n\n\nRelated packages\n\n\n\n\nPolynomials.jl\n: Polynomial manipulations\n\n\nPowerSeries.jl\n: Truncated power series for Julia\n\n\nMultiPoly.jl\n Sparse multivariate polynomials in Julia\n\n\n\n\n\n\nReferences\n\n\n\n\nW. Tucker, \nValidated Numerics: A Short Introduction to Rigorous Computations\n, Princeton University Press (2011).\n\n\nA. Haro, \nAutomatic differentiation methods in computational dynamical systems: Invariant manifolds and normal forms of vector fields at fixed points\n, \npreprint\n.\n\n\n\n\n\n\nAcknowledgments\n\n\nThis project began (using Python) during a Masters' course in the postgraduate programs in Physics and in Mathematics at UNAM, during the second half of 2013. We thank the participants of the course for putting up with the half-baked material and contributing energy and ideas.\n\n\nWe acknowledge financial support from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and PAPIIT grant IG-101113. LB acknowledges support through a \nC\u00e1tedra Moshinsky\n (2013).", 
            "title": "Home"
        }, 
        {
            "location": "/#taylorseriesjl", 
            "text": "A  Julia  package for Taylor expansions in one or more independent variables.", 
            "title": "TaylorSeries.jl"
        }, 
        {
            "location": "/#authors", 
            "text": "Luis Benet , Instituto de Ciencias F\u00edsicas, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)  David P. Sanders , Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)", 
            "title": "Authors"
        }, 
        {
            "location": "/#license", 
            "text": "TaylorSeries is licensed under the MIT \"Expat\" license; see  LICENSE  for the full license text.", 
            "title": "License"
        }, 
        {
            "location": "/#installation", 
            "text": "TaylorSeries.jl is a  registered package , and is simply installed by running  julia  Pkg.add( TaylorSeries )", 
            "title": "Installation"
        }, 
        {
            "location": "/#related-packages", 
            "text": "Polynomials.jl : Polynomial manipulations  PowerSeries.jl : Truncated power series for Julia  MultiPoly.jl  Sparse multivariate polynomials in Julia", 
            "title": "Related packages"
        }, 
        {
            "location": "/#references", 
            "text": "W. Tucker,  Validated Numerics: A Short Introduction to Rigorous Computations , Princeton University Press (2011).  A. Haro,  Automatic differentiation methods in computational dynamical systems: Invariant manifolds and normal forms of vector fields at fixed points ,  preprint .", 
            "title": "References"
        }, 
        {
            "location": "/#acknowledgments", 
            "text": "This project began (using Python) during a Masters' course in the postgraduate programs in Physics and in Mathematics at UNAM, during the second half of 2013. We thank the participants of the course for putting up with the half-baked material and contributing energy and ideas.  We acknowledge financial support from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and PAPIIT grant IG-101113. LB acknowledges support through a  C\u00e1tedra Moshinsky  (2013).", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/background/", 
            "text": "Background\n\n\n\n\n\n\nIntroduction\n\n\nTaylorSeries.jl\n is an implementation of high-order \nautomatic differentiation\n, as presented in the book by W. Tucker \n[1]\n. The general idea is the following.\n\n\nThe Taylor series expansion of an analytical function $f(t)$ with \none\n independent variable $t$ around $t_0$ can be written as \n\\begin{equation} f(t) = f_0 + f_1 (t-t_0) + f_2 (t-t_0)^2 + \\cdots + f_k (t-t_0)^k + \\cdots, \\end{equation}\n where $f_0=f(t_0)$, and the Taylor coefficients $f_k = f_k(t_0)$ are the $k$-th \nnormalized derivatives\n at $t_0$: \n\\begin{equation} f_k = \\frac{1}{k!} \\frac{{\\rm d}^k f} {{\\rm d} t^k}(t_0). \\end{equation}\n Thus, computing the high-order derivatives of $f(x)$ is equivalent to computing its Taylor expansion.\n\n\nIn the case of \nmany\n independent variables the same statements hold, though things become more subtle. Following Alex Haro's approach \n[2]\n, the Taylor expansion is an infinite sum of \nhomogeneous polynomials\n in the $d$ independent variables $x_1, x_2, \\dots, x_d$, which takes the form\n\n\n\n\n\\begin{equation} f_k (\\mathbf{x_0}) = \\sum_{m_1+\\cdots+m_d = k}\\, f_{m_1,\\dots,m_d} \\;\\, (x_1-x_{0_1})^{m_1} \\cdots (x_d-x_{0_d})^{m_d} = \\sum_{|\\mathbf{m}|=k} f_\\mathbf{m}\\, (\\mathbf{x}-\\mathbf{x_0})^\\mathbf{m}. \\end{equation}\n\n\n\n\nHere, $\\mathbf{m}\\in \\mathbb{N}^d$ is a multi-index of the $k$-th order homogeneous polynomial and $\\mathbf{x}=(x_1,x_2,\\ldots,x_d)$ are the $d$ independent variables.\n\n\nIn both cases, a Taylor series expansion can be represented by a vector containing its coefficients. The difference between the cases of one or more independent variables is that the coefficients are real or complex numbers in the former case, but homogeneous polynomials in the latter case. This motivates the construction of the \nTaylor\n and \nTaylorN\n types, described later.\n\n\n\n\nArithmetic operations\n\n\nArithmetic operations involving Taylor series can be expressed as operations on the coefficients:\n\n\n\n\n\\begin{eqnarray} (f(x) \\pm g(x))_k & = & f_k \\pm g_k \\, , \\\\\n\\label{eq:multT} (f(x) \\cdot g(x))_k & = & \\sum_{i=0}^k f_i \\, g_{k-i} \\, ,\\\\\n\\Big(\\frac{f(x)}{g(x)}\\Big)_k & = & \\frac{1}{g_0} \\Big[ f_k - \\sum_{i=0}^{k-1} \\big(\\frac{f(x)}{g(x)}\\big)_i \\, g_{k-i} \\Big]\\, .\\\\\n\\end{eqnarray}\n\n\n\n\nEquation (\\ref{eq:multT}) corresponds to a convolution.\n\n\n\n\nElementary functions of polynomials\n\n\nConsider a function $y(t)$ that satisfies the ordinary differential equation $\\dot{y} = f(y)$, $y(t_0)=y_0$, where $t$ is the independent variable. Writing $y(t)$ and $f(t)$ as Taylor polynomials of $t$, substituting these in the differential equation and equating equal powers of the independent variable leads to the recursion relation\n\n\n\n\n\\begin{equation} \\label{eq:rec} y_{n+1} = \\frac{f_n}{n+1}. \\end{equation}\n\n\n\n\nEquation (\\ref{eq:rec}), together with the corresponding initial condition, defines a recurrence relation for the Taylor coefficients of $y(t)$ around $t_0$. For more independent variables, using the chain rule for the \nradial derivative\n yields recurrence relations for the homogeneous polynomial coefficients of the function; see \n[2]\n.\n\n\nThe following are  examples of elementary functions constructed by such recurrence relations:\n\n\n\n\n\\begin{eqnarray} p(t)=(f(t))^\\alpha , \\qquad &   p_k & = \\frac{1}{k \\, f_0}\\sum_{j=0}^{k-1}\\big( \\alpha(k-j)-j\\big)   \\, f_{k-j} \\, p_j; \\\\\ne(t) = \\exp(t) , \\qquad &   e_k & = \\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) \\, f_{k-j} \\, e_j; \\\\\nl(t) = \\log(t) , \\qquad &   l_k & = \\frac{1}{f_0}\\big( f_k - \\frac{1}{k}\\sum_{j=1}^{k-1} j     \\, f_{k-j} \\, l_j \\big); \\\\\ns(t) = \\sin(t) , \\qquad &   s_k & = \\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) \\, f_{k-j} \\, c_j; \\\\\nc(t) = \\cos(t) , \\qquad &   c_k & = -\\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) \\, f_{k-j} \\, s_j. \\end{eqnarray}\n\n\n\n\nThe recursion relations for $s(t) = \\sin(f(t))$ and $c(t) = \\cos(f(t))$ depend on each other; this reflects the fact that they are solutions of a second-order differential equation. All these relations hold for Taylor expansions in one and more independent variables; in the latter case, the Taylor coefficients $f_k$ are homogeneous polynomials of degree $k$.\n\n\n\n\nReferences\n\n\n[1] W. Tucker, \nValidated Numerics: A Short Introduction to Rigorous Computations\n, Princeton University Press (2011).\n\n\n[2] A. Haro, \nAutomatic differentiation methods in computational dynamical systems: Invariant manifolds and normal forms of vector fields at fixed points\n, \npreprint\n.", 
            "title": "Background"
        }, 
        {
            "location": "/background/#background", 
            "text": "", 
            "title": "Background"
        }, 
        {
            "location": "/background/#introduction", 
            "text": "TaylorSeries.jl  is an implementation of high-order  automatic differentiation , as presented in the book by W. Tucker  [1] . The general idea is the following.  The Taylor series expansion of an analytical function $f(t)$ with  one  independent variable $t$ around $t_0$ can be written as  \\begin{equation} f(t) = f_0 + f_1 (t-t_0) + f_2 (t-t_0)^2 + \\cdots + f_k (t-t_0)^k + \\cdots, \\end{equation}  where $f_0=f(t_0)$, and the Taylor coefficients $f_k = f_k(t_0)$ are the $k$-th  normalized derivatives  at $t_0$:  \\begin{equation} f_k = \\frac{1}{k!} \\frac{{\\rm d}^k f} {{\\rm d} t^k}(t_0). \\end{equation}  Thus, computing the high-order derivatives of $f(x)$ is equivalent to computing its Taylor expansion.  In the case of  many  independent variables the same statements hold, though things become more subtle. Following Alex Haro's approach  [2] , the Taylor expansion is an infinite sum of  homogeneous polynomials  in the $d$ independent variables $x_1, x_2, \\dots, x_d$, which takes the form   \\begin{equation} f_k (\\mathbf{x_0}) = \\sum_{m_1+\\cdots+m_d = k}\\, f_{m_1,\\dots,m_d} \\;\\, (x_1-x_{0_1})^{m_1} \\cdots (x_d-x_{0_d})^{m_d} = \\sum_{|\\mathbf{m}|=k} f_\\mathbf{m}\\, (\\mathbf{x}-\\mathbf{x_0})^\\mathbf{m}. \\end{equation}   Here, $\\mathbf{m}\\in \\mathbb{N}^d$ is a multi-index of the $k$-th order homogeneous polynomial and $\\mathbf{x}=(x_1,x_2,\\ldots,x_d)$ are the $d$ independent variables.  In both cases, a Taylor series expansion can be represented by a vector containing its coefficients. The difference between the cases of one or more independent variables is that the coefficients are real or complex numbers in the former case, but homogeneous polynomials in the latter case. This motivates the construction of the  Taylor  and  TaylorN  types, described later.", 
            "title": "Introduction"
        }, 
        {
            "location": "/background/#arithmetic-operations", 
            "text": "Arithmetic operations involving Taylor series can be expressed as operations on the coefficients:   \\begin{eqnarray} (f(x) \\pm g(x))_k & = & f_k \\pm g_k \\, , \\\\\n\\label{eq:multT} (f(x) \\cdot g(x))_k & = & \\sum_{i=0}^k f_i \\, g_{k-i} \\, ,\\\\\n\\Big(\\frac{f(x)}{g(x)}\\Big)_k & = & \\frac{1}{g_0} \\Big[ f_k - \\sum_{i=0}^{k-1} \\big(\\frac{f(x)}{g(x)}\\big)_i \\, g_{k-i} \\Big]\\, .\\\\\n\\end{eqnarray}   Equation (\\ref{eq:multT}) corresponds to a convolution.", 
            "title": "Arithmetic operations"
        }, 
        {
            "location": "/background/#elementary-functions-of-polynomials", 
            "text": "Consider a function $y(t)$ that satisfies the ordinary differential equation $\\dot{y} = f(y)$, $y(t_0)=y_0$, where $t$ is the independent variable. Writing $y(t)$ and $f(t)$ as Taylor polynomials of $t$, substituting these in the differential equation and equating equal powers of the independent variable leads to the recursion relation   \\begin{equation} \\label{eq:rec} y_{n+1} = \\frac{f_n}{n+1}. \\end{equation}   Equation (\\ref{eq:rec}), together with the corresponding initial condition, defines a recurrence relation for the Taylor coefficients of $y(t)$ around $t_0$. For more independent variables, using the chain rule for the  radial derivative  yields recurrence relations for the homogeneous polynomial coefficients of the function; see  [2] .  The following are  examples of elementary functions constructed by such recurrence relations:   \\begin{eqnarray} p(t)=(f(t))^\\alpha , \\qquad &   p_k & = \\frac{1}{k \\, f_0}\\sum_{j=0}^{k-1}\\big( \\alpha(k-j)-j\\big)   \\, f_{k-j} \\, p_j; \\\\\ne(t) = \\exp(t) , \\qquad &   e_k & = \\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) \\, f_{k-j} \\, e_j; \\\\\nl(t) = \\log(t) , \\qquad &   l_k & = \\frac{1}{f_0}\\big( f_k - \\frac{1}{k}\\sum_{j=1}^{k-1} j     \\, f_{k-j} \\, l_j \\big); \\\\\ns(t) = \\sin(t) , \\qquad &   s_k & = \\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) \\, f_{k-j} \\, c_j; \\\\\nc(t) = \\cos(t) , \\qquad &   c_k & = -\\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) \\, f_{k-j} \\, s_j. \\end{eqnarray}   The recursion relations for $s(t) = \\sin(f(t))$ and $c(t) = \\cos(f(t))$ depend on each other; this reflects the fact that they are solutions of a second-order differential equation. All these relations hold for Taylor expansions in one and more independent variables; in the latter case, the Taylor coefficients $f_k$ are homogeneous polynomials of degree $k$.", 
            "title": "Elementary functions of polynomials"
        }, 
        {
            "location": "/background/#references", 
            "text": "[1] W. Tucker,  Validated Numerics: A Short Introduction to Rigorous Computations , Princeton University Press (2011).  [2] A. Haro,  Automatic differentiation methods in computational dynamical systems: Invariant manifolds and normal forms of vector fields at fixed points ,  preprint .", 
            "title": "References"
        }, 
        {
            "location": "/userguide/", 
            "text": "User guide\n\n\n\n\nTaylorSeries.jl\n is a basic polynomial algebraic manipulator in one or more variables; these two cases are treated separately.  Three new types are defined, \nTaylor1\n, \nHomogeneousPolynomial\n and \nTaylorN\n, which correspond to expansions in one independent variable, homogeneous polynomials of various variables, and the polynomial series in many independent variables, respectively. These types are subtypes of \nNumber\n and are defined parametrically.\n\n\nThe package is loaded as usual:\n\n\njulia\n using TaylorSeries\n\n\n\n\n\n\nOne variable\n\n\nTaylor expansions in one variable are represented by the \nTaylor1\n type, which consists of a vector of coefficients (field \ncoeffs\n) and the maximum order considered for the expansion (field \norder\n). The coefficients are arranged in ascending order with respect to the power of the independent variable, so that \ncoeffs[1]\n is the constant term, \ncoeffs[2]\n gives the first order term, etc. This is a dense representation of the polynomial. The order of the polynomial can be omitted in the constructor, which is then fixed from the length of the vector of coefficients; otherwise, the maximum of the length of the vector of coefficients and the given integer is taken.\n\n\njulia\n Taylor1([1, 2, 3]) # Polynomial of order 2 with coefficients 1, 2, 3\n 1 + 2 t + 3 t\u00b2 + \ud835\udcaa(t\u00b3)\n\njulia\n Taylor1([0.0, 1im]) # Also works with complex numbers\n ( 1.0 im ) t + \ud835\udcaa(t\u00b2)\n\njulia\n affine(a) = a + Taylor1(typeof(a),5)  ## a + taylor-polynomial of order 5\naffine (generic function with 1 method)\n\njulia\n t = affine(0.0) # Independent variable `t`\n 1.0 t + \ud835\udcaa(t\u2076)\n\n\n\n\nNote that the information about the maximum order considered is displayed using a big-O notation.\n\n\nThe definition of \naffine(a)\n uses the method \nTaylor1{T\n:Number}(::Type{T},::Int)\n, which is a shortcut to define the independent variable of a Taylor expansion, of given type (default is \nFloat64\n) and given order. As we show below, this is one of the easiest ways to work with the package.\n\n\nThe usual arithmetic operators (\n+\n, \n-\n, \n*\n, \n/\n, \n^\n, \n==\n) have been extended to work with the \nTaylor1\n type, including promotions that involve \nNumber\ns. The operations return a valid Taylor expansion with the same maximum order; compare the last example below, where this is not possible:\n\n\njulia\n t*(3t+2.5)\n 2.5 t + 3.0 t\u00b2 + \ud835\udcaa(t\u2076)\n\njulia\n 1/(1-t)\n 1.0 + 1.0 t + 1.0 t\u00b2 + 1.0 t\u00b3 + 1.0 t\u2074 + 1.0 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n t*(t^2-4)/(t+2)\n - 2.0 t + 1.0 t\u00b2 + \ud835\udcaa(t\u2076)\n\njulia\n tI = im*t\n ( 1.0 im ) t + \ud835\udcaa(t\u2076)\n\njulia\n t^6  # order is 5\n 0.0 + \ud835\udcaa(t\u2076)\n\njulia\n (1-t)^3.2\n 1.0 - 3.2 t + 3.5200000000000005 t\u00b2 - 1.4080000000000004 t\u00b3 + 0.07040000000000009 t\u2074 + 0.011264000000000012 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n (1+t)^t\n 1.0 + 1.0 t\u00b2 - 0.5 t\u00b3 + 0.8333333333333333 t\u2074 - 0.75 t\u2075 + \ud835\udcaa(t\u2076)\n\n\n\n\nIf no valid Taylor expansion can be computed, an error is thrown.\n\n\njulia\n 1/t\nERROR: ArgumentError: Division does not define a Taylor1 polynomial\nor its first non-zero coefficient is Inf/NaN.\nOrder k=0 =\n coeff[1]=Inf.\n\njulia\n t^3.2\nERROR: ArgumentError: The 0th order Taylor1 coefficient must be non-zero\nto raise the Taylor1 polynomial to a non-integer exponent.\n\n\n\n\nSeveral elementary functions have been implemented; these compute their coefficients recursively. So far, these functions are \nexp\n, \nlog\n, \nsqrt\n, \nsin\n, \ncos\n and \ntan\n; more will be added in the future. Note that this way of obtaining the Taylor coefficients is not the \nlaziest\n way, in particular for many independent variables. Yet, it is quite efficient, especially for the integration of ordinary differential equations, which is among the applications we have in mind.\n\n\njulia\n exp(t)\n 1.0 + 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n log(1-t)\n - 1.0 t - 0.5 t\u00b2 - 0.3333333333333333 t\u00b3 - 0.25 t\u2074 - 0.2 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n sqrt(1 + t)\n 1.0 + 0.5 t - 0.125 t\u00b2 + 0.0625 t\u00b3 - 0.0390625 t\u2074 + 0.02734375 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n imag(exp(tI)')\n - 1.0 t + 0.16666666666666666 t\u00b3 - 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n real(exp(Taylor1([0.0,1im],17))) - cos(Taylor1([0.0,1.0],17)) == 0.0\ntrue\n\njulia\n convert(Taylor1{Rational{Int64}}, exp(t))\n 1//1 + 1//1 t + 1//2 t\u00b2 + 1//6 t\u00b3 + 1//24 t\u2074 + 1//120 t\u2075 + \ud835\udcaa(t\u2076)\n\n\n\n\nAgain, errors are thrown whenever it is necessary.\n\n\njulia\n sqrt(t)\nERROR: ArgumentError: First non-vanishing Taylor1 coefficient must correspond\nto an **even power** in order to expand `sqrt` around 0.\n\njulia\n log(t)\nERROR: ArgumentError: Impossible to expand `log` around 0.\n\n\n\n\nDifferentiating and integrating is straightforward for polynomial expansions in one variable, using \nderivative\n and \nintegrate\n. These functions return the corresponding \nTaylor1\n expansions. The last coefficient of a derivative is set to zero to keep the same order as the original polynomial; for the integral, an integration constant may be set (the default is zero). The order of the resulting polynomial is not changed. The value of the $n$-th ($n \\ge 0$) derivative is obtained using \nderivative(n,a)\n, where \na\n is a Taylor series.\n\n\njulia\n derivative(exp(t))\n 1.0 + 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + \ud835\udcaa(t\u2076)\n\njulia\n integrate(exp(t))\n 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n integrate( exp(t), 1.0)\n 1.0 + 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia\n integrate( derivative( exp(-t)), 1.0 ) == exp(-t)\ntrue\n\njulia\n derivative(1, exp(affine(1.0))) == exp(1.0)\ntrue\n\njulia\n derivative(5, exp(affine(1.0))) == exp(1.0) # Fifth derivative of `exp(1+t)`\ntrue\n\n\n\n\nTo evaluate a Taylor series at a point, Horner's rule is used via the function \nevaluate(a, dt)\n. Here, \ndt\n is the increment from the point $t_0$ where the Taylor expansion of \na\n is calculated, i.e., the series is evaluated at $t = t_0 + dt$. Omitting \ndt\n corresponds to $dt = 0$. See \nevaluate\n.\n\n\njulia\n evaluate(exp(affine(1.0))) - e # exp(t) around t0=1 (order 5), evaluated there (dt=0)\n0.0\n\njulia\n evaluate(exp(t), 1) - e # exp(t) around t0=0 (order 5), evaluated at t=1\n-0.0016151617923783057\n\njulia\n evaluate( exp( Taylor1(17) ), 1) - e # exp(t) around t0=0, order 17\n0.0\n\njulia\n tBig = Taylor1([zero(BigFloat),one(BigFloat)],50) # With BigFloats\n 1.000000000000000000000000000000000000000000000000000000000000000000000000000000 t + \ud835\udcaa(t\u2075\u00b9)\n\njulia\n eBig = evaluate( exp(tBig), one(BigFloat) )\n2.718281828459045235360287471352662497757247093699959574966967627723419298053556\n\njulia\n e - eBig\n6.573322999985292556154129119543257102601105719980995128942636339920549561322098e-67\n\n\n\n\n\n\nMany variables\n\n\nA polynomial in $N\n1$ variables can be represented in (at least) two ways: As a vector whose coefficients are homogeneous polynomials of fixed degree, or as a vector whose coefficients are polynomials in $N-1$ variables. We have opted to implement the first option, which seems to show better performance. An elegant (lazy) implementation of the second representation was discussed on the \njulia-users\n list.\n\n\nTaylorN\n is thus constructed as a vector of parameterized homogeneous polynomials defined by the type \nHomogeneousPolynomial\n, which in turn is a vector of coefficients of given order (degree). This implementation imposes that the user has to specify the (maximum) order and the number of independent variables, which is done using the \nset_variables\n function. A vector of the resulting Taylor variables is returned:\n\n\njulia\n x, y = set_variables(\nx y\n)\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 x + \ud835\udcaa(\u2016x\u2016\u2077)\n  1.0 y + \ud835\udcaa(\u2016x\u2016\u2077)\n\njulia\n typeof(x)\nTaylorSeries.TaylorN{Float64}\n\njulia\n x.order\n6\n\njulia\n x.coeffs\n7-element Array{TaylorSeries.HomogeneousPolynomial{Float64},1}:\n    0.0\n  1.0 x\n    0.0\n    0.0\n    0.0\n    0.0\n    0.0\n\n\n\n\nAs shown, the resulting objects are of \nTaylorN{Float64}\n type. There is an optional \norder\n keyword argument for \nset_variables\n:\n\n\njulia\n set_variables(\nx y\n, order=10)\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 x + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n  1.0 y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia\n x\n 1.0 x + \ud835\udcaa(\u2016x\u2016\u2077)\n\n\n\n\nNumbered variables are also available by specifying a single variable name and the optional keyword argument \nnumvars\n:\n\n\njulia\n set_variables(\n\u03b1\n, numvars=3)\n3-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 \u03b1\u2081 + \ud835\udcaa(\u2016x\u2016\u2077)\n  1.0 \u03b1\u2082 + \ud835\udcaa(\u2016x\u2016\u2077)\n  1.0 \u03b1\u2083 + \ud835\udcaa(\u2016x\u2016\u2077)\n\n\n\n\nThe function \nshow_params_TaylorN\n displays the current values of the parameters, in an info block.\n\n\njulia\n show_params_TaylorN()\nINFO: Parameters for `TaylorN` and `HomogeneousPolynomial`:\nMaximum order       = 6\nNumber of variables = 3\nVariable names      = UTF8String[\n\u03b1\u2081\n,\n\u03b1\u2082\n,\n\u03b1\u2083\n]\n\n\n\n\nInternally, changing these parameters defines dictionaries that translate the position of the coefficients of a \nHomogeneousPolynomial\n into the corresponding multi-variable monomials. Fixing these values from the start is imperative.\n\n\nThe easiest way to construct a \nTaylorN\n object is by defining symbols for the independent variables, as above. Again, the Taylor expansions are implemented around 0 for all variables; if the expansion is needed around a different value, the trick is a simple translation of the corresponding independent variable $x \\to x+a$.\n\n\nOther ways of constructing \nTaylorN\n polynomials involve using \nHomogeneousPolynomial\n objects directly, which is uncomfortable; see below. A better alternative is to use the methods \nTaylorN{T\n:Number}(::Type{T}, nv::Int)\n which define the \nnv\n independent \nTaylorN\n variable of type \nT\n; the order can be also specified using the keyword argument \norder\n.\n\n\njulia\n set_variables(\nx\n, numvars=2);\n\njulia\n HomogeneousPolynomial([1,-1])\n 1 x\u2081 - 1 x\u2082\n\njulia\n TaylorN([HomogeneousPolynomial([1,0]), HomogeneousPolynomial([1,2,3])],4)\n 1 x\u2081 + 1 x\u2081\u00b2 + 2 x\u2081 x\u2082 + 3 x\u2082\u00b2 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia\n TaylorN(1,order=4) # variable 1 of order 4\n 1.0 x\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia\n TaylorN(Int, 2)    # variable 2, type Int, order=get_order()=7\n 1 x\u2082 + \ud835\udcaa(\u2016x\u2016\u2077)\n\n\n\n\nAs before, the usual arithmetic operators (\n+\n, \n-\n, \n*\n, \n/\n, \n^\n, \n==\n) have been extended to work with \nTaylorN\n objects, including the appropriate promotions to deal with numbers. (Some of the arithmetic operations have also been extended for \nHomogeneousPolynomial\n, whenever the result is a \nHomogeneousPolynomial\n; division, for instance, is not extended.) Also, the elementary functions have been implemented, again by computing their coefficients recursively:\n\n\njulia\n x, y = set_variables(\nx y\n, order=10);\n\njulia\n exy = exp(x+y)\n 1.0 + 1.0 x + 1.0 y + 0.5 x\u00b2 + 1.0 x y + 0.5 y\u00b2 + 0.16666666666666666 x\u00b3 + 0.5 x\u00b2 y + 0.5 x y\u00b2 + 0.16666666666666666 y\u00b3 + 0.041666666666666664 x\u2074 + 0.16666666666666666 x\u00b3 y + 0.25 x\u00b2 y\u00b2 + 0.16666666666666666 x y\u00b3 + 0.041666666666666664 y\u2074 + 0.008333333333333333 x\u2075 + 0.041666666666666664 x\u2074 y + 0.08333333333333333 x\u00b3 y\u00b2 + 0.08333333333333333 x\u00b2 y\u00b3 + 0.041666666666666664 x y\u2074 + 0.008333333333333333 y\u2075 + 0.0013888888888888887 x\u2076 + 0.008333333333333331 x\u2075 y + 0.020833333333333332 x\u2074 y\u00b2 + 0.027777777777777776 x\u00b3 y\u00b3 + 0.020833333333333332 x\u00b2 y\u2074 + 0.008333333333333331 x y\u2075 + 0.0013888888888888887 y\u2076 + 0.00019841269841269839 x\u2077 + 0.0013888888888888885 x\u2076 y + 0.004166666666666666 x\u2075 y\u00b2 + 0.006944444444444443 x\u2074 y\u00b3 + 0.006944444444444443 x\u00b3 y\u2074 + 0.004166666666666666 x\u00b2 y\u2075 + 0.0013888888888888885 x y\u2076 + 0.00019841269841269839 y\u2077 + 2.4801587301587298e-5 x\u2078 + 0.00019841269841269836 x\u2077 y + 0.0006944444444444443 x\u2076 y\u00b2 + 0.0013888888888888887 x\u2075 y\u00b3 + 0.0017361111111111108 x\u2074 y\u2074 + 0.0013888888888888887 x\u00b3 y\u2075 + 0.0006944444444444443 x\u00b2 y\u2076 + 0.00019841269841269836 x y\u2077 + 2.4801587301587298e-5 y\u2078 + 2.7557319223985884e-6 x\u2079 + 2.4801587301587295e-5 x\u2078 y + 9.920634920634918e-5 x\u2077 y\u00b2 + 0.0002314814814814814 x\u2076 y\u00b3 + 0.0003472222222222221 x\u2075 y\u2074 + 0.0003472222222222221 x\u2074 y\u2075 + 0.0002314814814814814 x\u00b3 y\u2076 + 9.920634920634918e-5 x\u00b2 y\u2077 + 2.4801587301587295e-5 x y\u2078 + 2.7557319223985884e-6 y\u2079 + 2.7557319223985883e-7 x\u00b9\u2070 + 2.7557319223985884e-6 x\u2079 y + 1.2400793650793647e-5 x\u2078 y\u00b2 + 3.306878306878306e-5 x\u2077 y\u00b3 + 5.787037037037036e-5 x\u2076 y\u2074 + 6.944444444444443e-5 x\u2075 y\u2075 + 5.787037037037036e-5 x\u2074 y\u2076 + 3.306878306878306e-5 x\u00b3 y\u2077 + 1.2400793650793647e-5 x\u00b2 y\u2078 + 2.7557319223985884e-6 x y\u2079 + 2.7557319223985883e-7 y\u00b9\u2070 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\n\n\n\nThe function \nget_coeff\n gives the coefficient the polynomial that corresponds to the monomial specified by a vector containing the powers \nv\n. Foe instance, for the polynomial \nexy\n above, the coefficient of the monomial $x^3 y^5$ is\n\n\njulia\n get_coeff(exy, [3,5])\n0.0013888888888888887\n\njulia\n rationalize(ans)\n1//720\n\n\n\n\nPartial differentiation is also implemented for \nTaylorN\n objects, through the function \nderivative\n, specifying the number of the variable as the second argument; integration is yet to be implemented.\n\n\njulia\n f = x^3 + 2x^2 * y - 7x + 2\n 2.0 - 7.0 x + 1.0 x\u00b3 + 2.0 x\u00b2 y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia\n g = y - x^4\n 1.0 y - 1.0 x\u2074 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia\n derivative( f, 1 )   # partial derivative with respect to 1st variable\n - 7.0 + 3.0 x\u00b2 + 4.0 x y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia\n derivative( g, 2 )\n 1.0 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\n\n\n\nIf we ask for the partial derivative with respect to a non-defined variable, an error is thrown.\n\n\njulia\n derivative( g, 3 )   # error, since we are dealing with 2 variables\nERROR: AssertionError: 1 \n= r \n= get_numvars()\n\n\n\n\nevaluate\n can also be used for \nTaylorN\n objects, using it on vectors of numbers (\nReal\n or \nComplex\n); the length of the vector must coincide with the number of independent variables.\n\n\njulia\n evaluate(exy, [.1,.02]) == e^0.12\ntrue\n\n\n\n\nFunctions to compute the gradient, Jacobian and Hessian have also been implemented. Using the polynomials $f = x^3 + 2x^2 y - 7 x + 2$ and $g = y-x^4$ defined above, we may use \ngradient\n (or \n\u2207\n); the results are of type \nArray{TaylorN{T},1}\n. To compute the Jacobian and Hessian of a vector field evaluated at a point, we use respectively \njacobian\n and \nhessian\n:\n\n\njulia\n \u2207(f)\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  - 7.0 + 3.0 x\u00b2 + 4.0 x y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n                    2.0 x\u00b2 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia\n gradient( g )\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  - 4.0 x\u00b3 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n       1.0 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia\n fg = f-g-2*f*g\n 2.0 - 7.0 x - 5.0 y + 14.0 x y + 1.0 x\u00b3 + 2.0 x\u00b2 y + 5.0 x\u2074 - 2.0 x\u00b3 y - 4.0 x\u00b2 y\u00b2 - 14.0 x\u2075 + 2.0 x\u2077 + 4.0 x\u2076 y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia\n hessian(ans)\n2\u00d72 Array{Float64,2}:\n  0.0  14.0\n 14.0   0.0\n\njulia\n jacobian([f,g], [2,1])\n2\u00d72 Array{Float64,2}:\n  13.0  8.0\n -32.0  1.0\n\njulia\n hessian(fg, [1.0,1.0])\n2\u00d72 Array{Float64,2}:\n -26.0  20.0\n  20.0  -8.0\n\n\n\n\nSome specific applications are given in the next \nsection\n.", 
            "title": "User guide"
        }, 
        {
            "location": "/userguide/#user-guide", 
            "text": "TaylorSeries.jl  is a basic polynomial algebraic manipulator in one or more variables; these two cases are treated separately.  Three new types are defined,  Taylor1 ,  HomogeneousPolynomial  and  TaylorN , which correspond to expansions in one independent variable, homogeneous polynomials of various variables, and the polynomial series in many independent variables, respectively. These types are subtypes of  Number  and are defined parametrically.  The package is loaded as usual:  julia  using TaylorSeries", 
            "title": "User guide"
        }, 
        {
            "location": "/userguide/#one-variable", 
            "text": "Taylor expansions in one variable are represented by the  Taylor1  type, which consists of a vector of coefficients (field  coeffs ) and the maximum order considered for the expansion (field  order ). The coefficients are arranged in ascending order with respect to the power of the independent variable, so that  coeffs[1]  is the constant term,  coeffs[2]  gives the first order term, etc. This is a dense representation of the polynomial. The order of the polynomial can be omitted in the constructor, which is then fixed from the length of the vector of coefficients; otherwise, the maximum of the length of the vector of coefficients and the given integer is taken.  julia  Taylor1([1, 2, 3]) # Polynomial of order 2 with coefficients 1, 2, 3\n 1 + 2 t + 3 t\u00b2 + \ud835\udcaa(t\u00b3)\n\njulia  Taylor1([0.0, 1im]) # Also works with complex numbers\n ( 1.0 im ) t + \ud835\udcaa(t\u00b2)\n\njulia  affine(a) = a + Taylor1(typeof(a),5)  ## a + taylor-polynomial of order 5\naffine (generic function with 1 method)\n\njulia  t = affine(0.0) # Independent variable `t`\n 1.0 t + \ud835\udcaa(t\u2076)  Note that the information about the maximum order considered is displayed using a big-O notation.  The definition of  affine(a)  uses the method  Taylor1{T :Number}(::Type{T},::Int) , which is a shortcut to define the independent variable of a Taylor expansion, of given type (default is  Float64 ) and given order. As we show below, this is one of the easiest ways to work with the package.  The usual arithmetic operators ( + ,  - ,  * ,  / ,  ^ ,  == ) have been extended to work with the  Taylor1  type, including promotions that involve  Number s. The operations return a valid Taylor expansion with the same maximum order; compare the last example below, where this is not possible:  julia  t*(3t+2.5)\n 2.5 t + 3.0 t\u00b2 + \ud835\udcaa(t\u2076)\n\njulia  1/(1-t)\n 1.0 + 1.0 t + 1.0 t\u00b2 + 1.0 t\u00b3 + 1.0 t\u2074 + 1.0 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  t*(t^2-4)/(t+2)\n - 2.0 t + 1.0 t\u00b2 + \ud835\udcaa(t\u2076)\n\njulia  tI = im*t\n ( 1.0 im ) t + \ud835\udcaa(t\u2076)\n\njulia  t^6  # order is 5\n 0.0 + \ud835\udcaa(t\u2076)\n\njulia  (1-t)^3.2\n 1.0 - 3.2 t + 3.5200000000000005 t\u00b2 - 1.4080000000000004 t\u00b3 + 0.07040000000000009 t\u2074 + 0.011264000000000012 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  (1+t)^t\n 1.0 + 1.0 t\u00b2 - 0.5 t\u00b3 + 0.8333333333333333 t\u2074 - 0.75 t\u2075 + \ud835\udcaa(t\u2076)  If no valid Taylor expansion can be computed, an error is thrown.  julia  1/t\nERROR: ArgumentError: Division does not define a Taylor1 polynomial\nor its first non-zero coefficient is Inf/NaN.\nOrder k=0 =  coeff[1]=Inf.\n\njulia  t^3.2\nERROR: ArgumentError: The 0th order Taylor1 coefficient must be non-zero\nto raise the Taylor1 polynomial to a non-integer exponent.  Several elementary functions have been implemented; these compute their coefficients recursively. So far, these functions are  exp ,  log ,  sqrt ,  sin ,  cos  and  tan ; more will be added in the future. Note that this way of obtaining the Taylor coefficients is not the  laziest  way, in particular for many independent variables. Yet, it is quite efficient, especially for the integration of ordinary differential equations, which is among the applications we have in mind.  julia  exp(t)\n 1.0 + 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  log(1-t)\n - 1.0 t - 0.5 t\u00b2 - 0.3333333333333333 t\u00b3 - 0.25 t\u2074 - 0.2 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  sqrt(1 + t)\n 1.0 + 0.5 t - 0.125 t\u00b2 + 0.0625 t\u00b3 - 0.0390625 t\u2074 + 0.02734375 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  imag(exp(tI)')\n - 1.0 t + 0.16666666666666666 t\u00b3 - 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  real(exp(Taylor1([0.0,1im],17))) - cos(Taylor1([0.0,1.0],17)) == 0.0\ntrue\n\njulia  convert(Taylor1{Rational{Int64}}, exp(t))\n 1//1 + 1//1 t + 1//2 t\u00b2 + 1//6 t\u00b3 + 1//24 t\u2074 + 1//120 t\u2075 + \ud835\udcaa(t\u2076)  Again, errors are thrown whenever it is necessary.  julia  sqrt(t)\nERROR: ArgumentError: First non-vanishing Taylor1 coefficient must correspond\nto an **even power** in order to expand `sqrt` around 0.\n\njulia  log(t)\nERROR: ArgumentError: Impossible to expand `log` around 0.  Differentiating and integrating is straightforward for polynomial expansions in one variable, using  derivative  and  integrate . These functions return the corresponding  Taylor1  expansions. The last coefficient of a derivative is set to zero to keep the same order as the original polynomial; for the integral, an integration constant may be set (the default is zero). The order of the resulting polynomial is not changed. The value of the $n$-th ($n \\ge 0$) derivative is obtained using  derivative(n,a) , where  a  is a Taylor series.  julia  derivative(exp(t))\n 1.0 + 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + \ud835\udcaa(t\u2076)\n\njulia  integrate(exp(t))\n 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  integrate( exp(t), 1.0)\n 1.0 + 1.0 t + 0.5 t\u00b2 + 0.16666666666666666 t\u00b3 + 0.041666666666666664 t\u2074 + 0.008333333333333333 t\u2075 + \ud835\udcaa(t\u2076)\n\njulia  integrate( derivative( exp(-t)), 1.0 ) == exp(-t)\ntrue\n\njulia  derivative(1, exp(affine(1.0))) == exp(1.0)\ntrue\n\njulia  derivative(5, exp(affine(1.0))) == exp(1.0) # Fifth derivative of `exp(1+t)`\ntrue  To evaluate a Taylor series at a point, Horner's rule is used via the function  evaluate(a, dt) . Here,  dt  is the increment from the point $t_0$ where the Taylor expansion of  a  is calculated, i.e., the series is evaluated at $t = t_0 + dt$. Omitting  dt  corresponds to $dt = 0$. See  evaluate .  julia  evaluate(exp(affine(1.0))) - e # exp(t) around t0=1 (order 5), evaluated there (dt=0)\n0.0\n\njulia  evaluate(exp(t), 1) - e # exp(t) around t0=0 (order 5), evaluated at t=1\n-0.0016151617923783057\n\njulia  evaluate( exp( Taylor1(17) ), 1) - e # exp(t) around t0=0, order 17\n0.0\n\njulia  tBig = Taylor1([zero(BigFloat),one(BigFloat)],50) # With BigFloats\n 1.000000000000000000000000000000000000000000000000000000000000000000000000000000 t + \ud835\udcaa(t\u2075\u00b9)\n\njulia  eBig = evaluate( exp(tBig), one(BigFloat) )\n2.718281828459045235360287471352662497757247093699959574966967627723419298053556\n\njulia  e - eBig\n6.573322999985292556154129119543257102601105719980995128942636339920549561322098e-67", 
            "title": "One variable"
        }, 
        {
            "location": "/userguide/#many-variables", 
            "text": "A polynomial in $N 1$ variables can be represented in (at least) two ways: As a vector whose coefficients are homogeneous polynomials of fixed degree, or as a vector whose coefficients are polynomials in $N-1$ variables. We have opted to implement the first option, which seems to show better performance. An elegant (lazy) implementation of the second representation was discussed on the  julia-users  list.  TaylorN  is thus constructed as a vector of parameterized homogeneous polynomials defined by the type  HomogeneousPolynomial , which in turn is a vector of coefficients of given order (degree). This implementation imposes that the user has to specify the (maximum) order and the number of independent variables, which is done using the  set_variables  function. A vector of the resulting Taylor variables is returned:  julia  x, y = set_variables( x y )\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 x + \ud835\udcaa(\u2016x\u2016\u2077)\n  1.0 y + \ud835\udcaa(\u2016x\u2016\u2077)\n\njulia  typeof(x)\nTaylorSeries.TaylorN{Float64}\n\njulia  x.order\n6\n\njulia  x.coeffs\n7-element Array{TaylorSeries.HomogeneousPolynomial{Float64},1}:\n    0.0\n  1.0 x\n    0.0\n    0.0\n    0.0\n    0.0\n    0.0  As shown, the resulting objects are of  TaylorN{Float64}  type. There is an optional  order  keyword argument for  set_variables :  julia  set_variables( x y , order=10)\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 x + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n  1.0 y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia  x\n 1.0 x + \ud835\udcaa(\u2016x\u2016\u2077)  Numbered variables are also available by specifying a single variable name and the optional keyword argument  numvars :  julia  set_variables( \u03b1 , numvars=3)\n3-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 \u03b1\u2081 + \ud835\udcaa(\u2016x\u2016\u2077)\n  1.0 \u03b1\u2082 + \ud835\udcaa(\u2016x\u2016\u2077)\n  1.0 \u03b1\u2083 + \ud835\udcaa(\u2016x\u2016\u2077)  The function  show_params_TaylorN  displays the current values of the parameters, in an info block.  julia  show_params_TaylorN()\nINFO: Parameters for `TaylorN` and `HomogeneousPolynomial`:\nMaximum order       = 6\nNumber of variables = 3\nVariable names      = UTF8String[ \u03b1\u2081 , \u03b1\u2082 , \u03b1\u2083 ]  Internally, changing these parameters defines dictionaries that translate the position of the coefficients of a  HomogeneousPolynomial  into the corresponding multi-variable monomials. Fixing these values from the start is imperative.  The easiest way to construct a  TaylorN  object is by defining symbols for the independent variables, as above. Again, the Taylor expansions are implemented around 0 for all variables; if the expansion is needed around a different value, the trick is a simple translation of the corresponding independent variable $x \\to x+a$.  Other ways of constructing  TaylorN  polynomials involve using  HomogeneousPolynomial  objects directly, which is uncomfortable; see below. A better alternative is to use the methods  TaylorN{T :Number}(::Type{T}, nv::Int)  which define the  nv  independent  TaylorN  variable of type  T ; the order can be also specified using the keyword argument  order .  julia  set_variables( x , numvars=2);\n\njulia  HomogeneousPolynomial([1,-1])\n 1 x\u2081 - 1 x\u2082\n\njulia  TaylorN([HomogeneousPolynomial([1,0]), HomogeneousPolynomial([1,2,3])],4)\n 1 x\u2081 + 1 x\u2081\u00b2 + 2 x\u2081 x\u2082 + 3 x\u2082\u00b2 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia  TaylorN(1,order=4) # variable 1 of order 4\n 1.0 x\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia  TaylorN(Int, 2)    # variable 2, type Int, order=get_order()=7\n 1 x\u2082 + \ud835\udcaa(\u2016x\u2016\u2077)  As before, the usual arithmetic operators ( + ,  - ,  * ,  / ,  ^ ,  == ) have been extended to work with  TaylorN  objects, including the appropriate promotions to deal with numbers. (Some of the arithmetic operations have also been extended for  HomogeneousPolynomial , whenever the result is a  HomogeneousPolynomial ; division, for instance, is not extended.) Also, the elementary functions have been implemented, again by computing their coefficients recursively:  julia  x, y = set_variables( x y , order=10);\n\njulia  exy = exp(x+y)\n 1.0 + 1.0 x + 1.0 y + 0.5 x\u00b2 + 1.0 x y + 0.5 y\u00b2 + 0.16666666666666666 x\u00b3 + 0.5 x\u00b2 y + 0.5 x y\u00b2 + 0.16666666666666666 y\u00b3 + 0.041666666666666664 x\u2074 + 0.16666666666666666 x\u00b3 y + 0.25 x\u00b2 y\u00b2 + 0.16666666666666666 x y\u00b3 + 0.041666666666666664 y\u2074 + 0.008333333333333333 x\u2075 + 0.041666666666666664 x\u2074 y + 0.08333333333333333 x\u00b3 y\u00b2 + 0.08333333333333333 x\u00b2 y\u00b3 + 0.041666666666666664 x y\u2074 + 0.008333333333333333 y\u2075 + 0.0013888888888888887 x\u2076 + 0.008333333333333331 x\u2075 y + 0.020833333333333332 x\u2074 y\u00b2 + 0.027777777777777776 x\u00b3 y\u00b3 + 0.020833333333333332 x\u00b2 y\u2074 + 0.008333333333333331 x y\u2075 + 0.0013888888888888887 y\u2076 + 0.00019841269841269839 x\u2077 + 0.0013888888888888885 x\u2076 y + 0.004166666666666666 x\u2075 y\u00b2 + 0.006944444444444443 x\u2074 y\u00b3 + 0.006944444444444443 x\u00b3 y\u2074 + 0.004166666666666666 x\u00b2 y\u2075 + 0.0013888888888888885 x y\u2076 + 0.00019841269841269839 y\u2077 + 2.4801587301587298e-5 x\u2078 + 0.00019841269841269836 x\u2077 y + 0.0006944444444444443 x\u2076 y\u00b2 + 0.0013888888888888887 x\u2075 y\u00b3 + 0.0017361111111111108 x\u2074 y\u2074 + 0.0013888888888888887 x\u00b3 y\u2075 + 0.0006944444444444443 x\u00b2 y\u2076 + 0.00019841269841269836 x y\u2077 + 2.4801587301587298e-5 y\u2078 + 2.7557319223985884e-6 x\u2079 + 2.4801587301587295e-5 x\u2078 y + 9.920634920634918e-5 x\u2077 y\u00b2 + 0.0002314814814814814 x\u2076 y\u00b3 + 0.0003472222222222221 x\u2075 y\u2074 + 0.0003472222222222221 x\u2074 y\u2075 + 0.0002314814814814814 x\u00b3 y\u2076 + 9.920634920634918e-5 x\u00b2 y\u2077 + 2.4801587301587295e-5 x y\u2078 + 2.7557319223985884e-6 y\u2079 + 2.7557319223985883e-7 x\u00b9\u2070 + 2.7557319223985884e-6 x\u2079 y + 1.2400793650793647e-5 x\u2078 y\u00b2 + 3.306878306878306e-5 x\u2077 y\u00b3 + 5.787037037037036e-5 x\u2076 y\u2074 + 6.944444444444443e-5 x\u2075 y\u2075 + 5.787037037037036e-5 x\u2074 y\u2076 + 3.306878306878306e-5 x\u00b3 y\u2077 + 1.2400793650793647e-5 x\u00b2 y\u2078 + 2.7557319223985884e-6 x y\u2079 + 2.7557319223985883e-7 y\u00b9\u2070 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)  The function  get_coeff  gives the coefficient the polynomial that corresponds to the monomial specified by a vector containing the powers  v . Foe instance, for the polynomial  exy  above, the coefficient of the monomial $x^3 y^5$ is  julia  get_coeff(exy, [3,5])\n0.0013888888888888887\n\njulia  rationalize(ans)\n1//720  Partial differentiation is also implemented for  TaylorN  objects, through the function  derivative , specifying the number of the variable as the second argument; integration is yet to be implemented.  julia  f = x^3 + 2x^2 * y - 7x + 2\n 2.0 - 7.0 x + 1.0 x\u00b3 + 2.0 x\u00b2 y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia  g = y - x^4\n 1.0 y - 1.0 x\u2074 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia  derivative( f, 1 )   # partial derivative with respect to 1st variable\n - 7.0 + 3.0 x\u00b2 + 4.0 x y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia  derivative( g, 2 )\n 1.0 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)  If we ask for the partial derivative with respect to a non-defined variable, an error is thrown.  julia  derivative( g, 3 )   # error, since we are dealing with 2 variables\nERROR: AssertionError: 1  = r  = get_numvars()  evaluate  can also be used for  TaylorN  objects, using it on vectors of numbers ( Real  or  Complex ); the length of the vector must coincide with the number of independent variables.  julia  evaluate(exy, [.1,.02]) == e^0.12\ntrue  Functions to compute the gradient, Jacobian and Hessian have also been implemented. Using the polynomials $f = x^3 + 2x^2 y - 7 x + 2$ and $g = y-x^4$ defined above, we may use  gradient  (or  \u2207 ); the results are of type  Array{TaylorN{T},1} . To compute the Jacobian and Hessian of a vector field evaluated at a point, we use respectively  jacobian  and  hessian :  julia  \u2207(f)\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  - 7.0 + 3.0 x\u00b2 + 4.0 x y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n                    2.0 x\u00b2 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia  gradient( g )\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  - 4.0 x\u00b3 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n       1.0 + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia  fg = f-g-2*f*g\n 2.0 - 7.0 x - 5.0 y + 14.0 x y + 1.0 x\u00b3 + 2.0 x\u00b2 y + 5.0 x\u2074 - 2.0 x\u00b3 y - 4.0 x\u00b2 y\u00b2 - 14.0 x\u2075 + 2.0 x\u2077 + 4.0 x\u2076 y + \ud835\udcaa(\u2016x\u2016\u00b9\u00b9)\n\njulia  hessian(ans)\n2\u00d72 Array{Float64,2}:\n  0.0  14.0\n 14.0   0.0\n\njulia  jacobian([f,g], [2,1])\n2\u00d72 Array{Float64,2}:\n  13.0  8.0\n -32.0  1.0\n\njulia  hessian(fg, [1.0,1.0])\n2\u00d72 Array{Float64,2}:\n -26.0  20.0\n  20.0  -8.0  Some specific applications are given in the next  section .", 
            "title": "Many variables"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\n\n\n\n\n1. Four-square identity\n\n\nThe first example shows that the four-square identity holds: \n\\begin{eqnarray} (a_1+a_2+a_3+a_4)\\cdot(b_1+b_2+b_3+b_4) & = &      (a_1 b_1 - a_2 b_2 - a_3 b_3 -a_4 b_4)^2 + \\qquad \\nonumber \\\\\n\\label{eq:Euler}   & & (a_1 b_2 - a_2 b_1 - a_3 b_4 -a_4 b_3)^2 + \\\\\n  & & (a_1 b_3 - a_2 b_4 - a_3 b_1 -a_4 b_2)^2 + \\nonumber \\\\\n  & & (a_1 b_4 - a_2 b_3 - a_3 b_2 -a_4 b_1)^2, \\nonumber \\end{eqnarray}\n as proved by Euler. The code can we found in one of the tests of the package.\n\n\nFirst, we reset the maximum degree of the polynomial to 4, since the RHS of the equation has \na priori\n terms of fourth order, and the number of independent variables to 8.\n\n\njulia\n using TaylorSeries\n\njulia\n # Define the variables \u03b1\u2081, ..., \u03b1\u2084, \u03b2\u2081, ..., \u03b2\u2084\n       make_variable(name, index::Int) = string(name, TaylorSeries.subscriptify(index))\nmake_variable (generic function with 1 method)\n\njulia\n variable_names = [make_variable(\n\u03b1\n, i) for i in 1:4]\n4-element Array{String,1}:\n \n\u03b1\u2081\n\n \n\u03b1\u2082\n\n \n\u03b1\u2083\n\n \n\u03b1\u2084\n\n\njulia\n append!(variable_names, [make_variable(\n\u03b2\n, i) for i in 1:4])\n8-element Array{String,1}:\n \n\u03b1\u2081\n\n \n\u03b1\u2082\n\n \n\u03b1\u2083\n\n \n\u03b1\u2084\n\n \n\u03b2\u2081\n\n \n\u03b2\u2082\n\n \n\u03b2\u2083\n\n \n\u03b2\u2084\n\n\njulia\n # Create the Taylor objects (order 4, numvars=8)\n       a1, a2, a3, a4, b1, b2, b3, b4 = set_variables(variable_names, order=4)\n8-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 \u03b1\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b1\u2082 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b1\u2083 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b1\u2084 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2082 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2083 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2084 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia\n a1 # variable a1\n 1.0 \u03b1\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)\n\n\n\n\nNow we compute each term appearing in (\\ref{eq:Euler}), and compare them\n\n\njulia\n # left-hand side\n       lhs1 = a1^2 + a2^2 + a3^2 + a4^2 ;\n\njulia\n lhs2 = b1^2 + b2^2 + b3^2 + b4^2 ;\n\njulia\n lhs = lhs1 * lhs2\n 1.0 \u03b1\u2081\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2084\u00b2 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia\n # right-hand side\n       rhs1 = (a1*b1 - a2*b2 - a3*b3 - a4*b4)^2 ;\n\njulia\n rhs2 = (a1*b2 + a2*b1 + a3*b4 - a4*b3)^2 ;\n\njulia\n rhs3 = (a1*b3 - a2*b4 + a3*b1 + a4*b2)^2 ;\n\njulia\n rhs4 = (a1*b4 + a2*b3 - a3*b2 + a4*b1)^2 ;\n\njulia\n rhs = rhs1 + rhs2 + rhs3 + rhs4\n 1.0 \u03b1\u2081\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2084\u00b2 + \ud835\udcaa(\u2016x\u2016\u2075)\n\n\n\n\nFinally, we compare the two sides of the identity,\n\n\njulia\n lhs == rhs\ntrue\n\n\n\n\nThe identity is satisfied. $\\square$.\n\n\n\n\n2. Fateman test\n\n\nRichard J. Fateman, from Berkley, proposed as a stringent test of polynomial multiplication the evaluation of $s*(s+1)$, where $s = (1+x+y+z+w)^{20}$. This is implemented in the function \nfateman1\n. We shall also evaluate the form $s^2+s$ in \nfateman2\n, which involves fewer operations (and makes a fairer comparison to what Mathematica does). Below we have used Julia v0.4.\n\n\njulia\n using TaylorSeries\n\njulia\n set_variables(\nx\n, numvars=4, order=40)\n4-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 x\u2081 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n  1.0 x\u2082 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n  1.0 x\u2083 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n  1.0 x\u2084 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n\njulia\n function fateman1(degree::Int)\n           T = Int128\n           oneH = HomogeneousPolynomial(one(T), 0)\n           # s = 1 + x + y + z + w\n           s = TaylorN([oneH,HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)],degree)\n           s = s^degree\n           # s is converted to order 2*ndeg\n           s = TaylorN(s, 2*degree)\n           s * ( s+TaylorN(oneH, 2*degree) )\n       end\nfateman1 (generic function with 1 method)\n\njulia\n fateman1(0);\n\njulia\n @time f1 = fateman1(20);\n  5.037958 seconds (3.56 k allocations: 20.147 MB, 0.12% gc time)\n\n\n\n\nAnother implementation of the same:\n\n\njulia\n function fateman2(degree::Int)\n           T = Int128\n           oneH = HomogeneousPolynomial(one(T), 0)\n           s = TaylorN([oneH,HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)],degree)\n           s = s^degree\n           # s is converted to order 2*ndeg\n           s = TaylorN(s, 2*degree)\n           return s^2 + s\n       end\nfateman2 (generic function with 1 method)\n\njulia\n fateman2(0);\n\njulia\n @time f2 = fateman2(20);\n  1.527958 seconds (3.40 k allocations: 20.137 MB, 0.38% gc time)\n\njulia\n get_coeff(f2,[1,6,7,20]) # coefficient of x y^6 z^7 w^{20}\n128358585324486316800\n\njulia\n sum(TaylorSeries.size_table)\n135751\n\n\n\n\nThe tests above show the necessity of using \nInt128\n, that \nfateman2\n is nearly twice as fast as \nfateman1\n, and that the series has 135751 monomials on 4 variables.\n\n\nMathematica (version 10.2) requires 3.139831 seconds. Then, with TaylorSeries v0.1.2, our implementation of \nfateman1\n is about 20% faster, and \nfateman2\n is more than a factor 2 faster. (The original test by Fateman corresponds to \nfateman1\n, which avoids specific optimizations in \n^2\n.)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#1-four-square-identity", 
            "text": "The first example shows that the four-square identity holds:  \\begin{eqnarray} (a_1+a_2+a_3+a_4)\\cdot(b_1+b_2+b_3+b_4) & = &      (a_1 b_1 - a_2 b_2 - a_3 b_3 -a_4 b_4)^2 + \\qquad \\nonumber \\\\\n\\label{eq:Euler}   & & (a_1 b_2 - a_2 b_1 - a_3 b_4 -a_4 b_3)^2 + \\\\\n  & & (a_1 b_3 - a_2 b_4 - a_3 b_1 -a_4 b_2)^2 + \\nonumber \\\\\n  & & (a_1 b_4 - a_2 b_3 - a_3 b_2 -a_4 b_1)^2, \\nonumber \\end{eqnarray}  as proved by Euler. The code can we found in one of the tests of the package.  First, we reset the maximum degree of the polynomial to 4, since the RHS of the equation has  a priori  terms of fourth order, and the number of independent variables to 8.  julia  using TaylorSeries\n\njulia  # Define the variables \u03b1\u2081, ..., \u03b1\u2084, \u03b2\u2081, ..., \u03b2\u2084\n       make_variable(name, index::Int) = string(name, TaylorSeries.subscriptify(index))\nmake_variable (generic function with 1 method)\n\njulia  variable_names = [make_variable( \u03b1 , i) for i in 1:4]\n4-element Array{String,1}:\n  \u03b1\u2081 \n  \u03b1\u2082 \n  \u03b1\u2083 \n  \u03b1\u2084 \n\njulia  append!(variable_names, [make_variable( \u03b2 , i) for i in 1:4])\n8-element Array{String,1}:\n  \u03b1\u2081 \n  \u03b1\u2082 \n  \u03b1\u2083 \n  \u03b1\u2084 \n  \u03b2\u2081 \n  \u03b2\u2082 \n  \u03b2\u2083 \n  \u03b2\u2084 \n\njulia  # Create the Taylor objects (order 4, numvars=8)\n       a1, a2, a3, a4, b1, b2, b3, b4 = set_variables(variable_names, order=4)\n8-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 \u03b1\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b1\u2082 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b1\u2083 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b1\u2084 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2082 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2083 + \ud835\udcaa(\u2016x\u2016\u2075)\n  1.0 \u03b2\u2084 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia  a1 # variable a1\n 1.0 \u03b1\u2081 + \ud835\udcaa(\u2016x\u2016\u2075)  Now we compute each term appearing in (\\ref{eq:Euler}), and compare them  julia  # left-hand side\n       lhs1 = a1^2 + a2^2 + a3^2 + a4^2 ;\n\njulia  lhs2 = b1^2 + b2^2 + b3^2 + b4^2 ;\n\njulia  lhs = lhs1 * lhs2\n 1.0 \u03b1\u2081\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2084\u00b2 + \ud835\udcaa(\u2016x\u2016\u2075)\n\njulia  # right-hand side\n       rhs1 = (a1*b1 - a2*b2 - a3*b3 - a4*b4)^2 ;\n\njulia  rhs2 = (a1*b2 + a2*b1 + a3*b4 - a4*b3)^2 ;\n\njulia  rhs3 = (a1*b3 - a2*b4 + a3*b1 + a4*b2)^2 ;\n\njulia  rhs4 = (a1*b4 + a2*b3 - a3*b2 + a4*b1)^2 ;\n\njulia  rhs = rhs1 + rhs2 + rhs3 + rhs4\n 1.0 \u03b1\u2081\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2081\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2082\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2083\u00b2 \u03b2\u2084\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2081\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2082\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2083\u00b2 + 1.0 \u03b1\u2084\u00b2 \u03b2\u2084\u00b2 + \ud835\udcaa(\u2016x\u2016\u2075)  Finally, we compare the two sides of the identity,  julia  lhs == rhs\ntrue  The identity is satisfied. $\\square$.", 
            "title": "1. Four-square identity"
        }, 
        {
            "location": "/examples/#2-fateman-test", 
            "text": "Richard J. Fateman, from Berkley, proposed as a stringent test of polynomial multiplication the evaluation of $s*(s+1)$, where $s = (1+x+y+z+w)^{20}$. This is implemented in the function  fateman1 . We shall also evaluate the form $s^2+s$ in  fateman2 , which involves fewer operations (and makes a fairer comparison to what Mathematica does). Below we have used Julia v0.4.  julia  using TaylorSeries\n\njulia  set_variables( x , numvars=4, order=40)\n4-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 x\u2081 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n  1.0 x\u2082 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n  1.0 x\u2083 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n  1.0 x\u2084 + \ud835\udcaa(\u2016x\u2016\u2074\u00b9)\n\njulia  function fateman1(degree::Int)\n           T = Int128\n           oneH = HomogeneousPolynomial(one(T), 0)\n           # s = 1 + x + y + z + w\n           s = TaylorN([oneH,HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)],degree)\n           s = s^degree\n           # s is converted to order 2*ndeg\n           s = TaylorN(s, 2*degree)\n           s * ( s+TaylorN(oneH, 2*degree) )\n       end\nfateman1 (generic function with 1 method)\n\njulia  fateman1(0);\n\njulia  @time f1 = fateman1(20);\n  5.037958 seconds (3.56 k allocations: 20.147 MB, 0.12% gc time)  Another implementation of the same:  julia  function fateman2(degree::Int)\n           T = Int128\n           oneH = HomogeneousPolynomial(one(T), 0)\n           s = TaylorN([oneH,HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)],degree)\n           s = s^degree\n           # s is converted to order 2*ndeg\n           s = TaylorN(s, 2*degree)\n           return s^2 + s\n       end\nfateman2 (generic function with 1 method)\n\njulia  fateman2(0);\n\njulia  @time f2 = fateman2(20);\n  1.527958 seconds (3.40 k allocations: 20.137 MB, 0.38% gc time)\n\njulia  get_coeff(f2,[1,6,7,20]) # coefficient of x y^6 z^7 w^{20}\n128358585324486316800\n\njulia  sum(TaylorSeries.size_table)\n135751  The tests above show the necessity of using  Int128 , that  fateman2  is nearly twice as fast as  fateman1 , and that the series has 135751 monomials on 4 variables.  Mathematica (version 10.2) requires 3.139831 seconds. Then, with TaylorSeries v0.1.2, our implementation of  fateman1  is about 20% faster, and  fateman2  is more than a factor 2 faster. (The original test by Fateman corresponds to  fateman1 , which avoids specific optimizations in  ^2 .)", 
            "title": "2. Fateman test"
        }, 
        {
            "location": "/api/", 
            "text": "Library\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nTaylorSeries.Taylor1\n \n \nType\n.\n\n\nTaylor1{T\n:Number} \n: Number\n\n\n\n\nDataType for polynomial expansions in one independent variable.\n\n\nFields:\n\n\n\n\ncoeffs :: Array{T,1}\n Expansion coefficients; the $i$-th component is the coefficient of degree $i-1$ of the expansion.\n\n\norder  :: Int64\n Maximum order (degree) of the polynomial.\n\n\n\n\nsource\n\n\nTaylor1(T, [order=1])\nTaylor1([order=1])\n\n\n\n\nShortcut to define the independent variable of a \nTaylor1{T}\n polynomial of given \norder\n. If the type \nT\n is ommitted, \nFloat64\n is assumend.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nTaylor1\n(\n)\n\n    defined at\n    \nsrc/Taylor1.jl:59\n\n\n\n\n\n    \nTaylor1\n{\nT\n<\n:Number\n}\n(\ncoeffs\n::\nArray{T,1}\n)\n\n    defined at\n    \nsrc/Taylor1.jl:46\n\n\n\n\n\n    \nTaylor1\n{\nT\n<\n:Number\n}\n(\n\n    \nx\n::\nTaylorSeries.Taylor1{T}\n,\n\n    \norder\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:43\n\n\n\n\n\n    \nTaylor1\n{\nT\n<\n:Number\n}\n(\nx\n::\nTaylorSeries.Taylor1{T}\n)\n\n    defined at\n    \nsrc/Taylor1.jl:44\n\n\n\n\n\n    \nTaylor1\n{\nT\n<\n:Number\n}\n(\n\n    \ncoeffs\n::\nArray{T,1}\n,\n\n    \norder\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:45\n\n\n\n\n\n    \nTaylor1\n(\norder\n::\nInt64\n)\n\n    defined at\n    \nsrc/Taylor1.jl:59\n\n\n\n\n\n    \nTaylor1\n{\nT\n<\n:Number\n}\n(\nx\n::\nT\n, \norder\n::\nInt64\n)\n\n    defined at\n    \nsrc/Taylor1.jl:47\n\n\n\n\n\n    \nTaylor1\n{\nT\n<\n:Number\n}\n(\n::\nType{T}\n)\n\n    defined at\n    \nsrc/Taylor1.jl:58\n\n\n\n\n\n    \nTaylor1\n{\nT\n<\n:Number\n}\n(\n::\nType{T}\n, \norder\n::\nInt64\n)\n\n    defined at\n    \nsrc/Taylor1.jl:58\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nTaylorSeries.HomogeneousPolynomial\n \n \nType\n.\n\n\nHomogeneousPolynomial{T\n:Number} \n: Number\n\n\n\n\nDataType for homogenous polynomials in many (\n1) independent variables.\n\n\nFields:\n\n\n\n\ncoeffs  :: Array{T,1}\n Expansion coefficients of the homogeneous polynomial; the $i$-th component is related to a monomial, where the degrees of the independent variables are specified by \ncoeff_table[order+1][i]\n.\n\n\norder   :: Int\n order (degree) of the homogenous polynomial.\n\n\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nHomogeneousPolynomial\n{\nT\n<\n:Number\n}\n(\ncoeffs\n::\nArray{T,1}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:56\n\n\n\n\n\n    \nHomogeneousPolynomial\n{\nT\n<\n:Number\n}\n(\n\n    \nx\n::\nTaylorSeries.HomogeneousPolynomial{T}\n,\n\n    \norder\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:51\n\n\n\n\n\n    \nHomogeneousPolynomial\n{\nT\n<\n:Number\n}\n(\nx\n::\nTaylorSeries.HomogeneousPolynomial{T}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:53\n\n\n\n\n\n    \nHomogeneousPolynomial\n{\nT\n<\n:Number\n}\n(\n\n    \ncoeffs\n::\nArray{T,1}\n,\n\n    \norder\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:54\n\n\n\n\n\n    \nHomogeneousPolynomial\n{\nT\n<\n:Number\n}\n(\nx\n::\nT\n, \norder\n::\nInt64\n)\n\n    defined at\n    \nsrc/TaylorN.jl:58\n\n\n\n\n\n    \nHomogeneousPolynomial\n{\nT\n<\n:Number\n}\n(\nx\n::\nT\n)\n\n    defined at\n    \nsrc/TaylorN.jl:60\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nTaylorSeries.TaylorN\n \n \nType\n.\n\n\nTaylorN{T\n:Number} \n: Number\n\n\n\n\nDataType for polynomial expansions in many (\n1) independent variables.\n\n\nFields:\n\n\n\n\ncoeffs  :: Array{HomogeneousPolynomial{T},1}\n Vector containing the \nHomogeneousPolynomial\n entries. The $i$-th component corresponds to the homogeneous polynomial of degree $i-1$.\n\n\norder   :: Int\n  maximum order of the polynomial expansion.\n\n\n\n\nsource\n\n\nTaylorN(T, nv; [order=get_order()])\nTaylorN(nv; [order=get_order()])\n\n\n\n\nShortcut to define the \nnv\n-th independent \nTaylorN{T}\n variable as a polynomial. The order is defined through the keyword parameter \norder\n, whose default corresponds to \nget_order()\n. If \nT::Type\n is ommitted, \nFloat64\n is assumend.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\nx\n::\nArray{TaylorSeries.HomogeneousPolynomial{T},1}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:177\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\n\n    \nx\n::\nTaylorSeries.TaylorN{T}\n,\n\n    \norder\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:173\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\nx\n::\nTaylorSeries.TaylorN{T}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:174\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\n\n    \nx\n::\nArray{TaylorSeries.HomogeneousPolynomial{T},1}\n,\n\n    \norder\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:175\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\n\n    \nx\n::\nTaylorSeries.HomogeneousPolynomial{T}\n,\n\n    \norder\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:178\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\nx\n::\nTaylorSeries.HomogeneousPolynomial{T}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:180\n\n\n\n\n\n    \nTaylorN\n(\nnv\n::\nInt64\n)\n\n    defined at\n    \nsrc/TaylorN.jl:201\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\nx\n::\nT\n, \norder\n::\nInt64\n)\n\n    defined at\n    \nsrc/TaylorN.jl:181\n\n\n\n\n\n    \nTaylorN\n{\nT\n<\n:Number\n}\n(\n::\nType{T}\n, \nnv\n::\nInt64\n)\n\n    defined at\n    \nsrc/TaylorN.jl:196\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n#\n\n\nTaylorSeries.ParamsTaylorN\n \n \nType\n.\n\n\nParamsTaylorN\n\n\n\n\nDataType holding the current parameters for \nTaylorN\n and \nHomogeneousPolynomial\n.\n\n\nFields:\n\n\n\n\norder          :: Int\n  Order (degree) of the polynomials\n\n\nnum_vars       :: Int\n  Number of variables\n\n\nvariable_names :: Array{String,1}\n Name of the variables\n\n\n\n\nThese parameters can be changed using \nset_params_TaylorN(order, numVars)\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nParamsTaylorN\n(\n\n    \norder\n::\nInt64\n,\n\n    \nnum_vars\n::\nInt64\n,\n\n    \nvariable_names\n::\nArray{String,1}\n\n\n)\n\n    defined at\n    \nsrc/parameters.jl:20\n\n\n\n\n\n    \nParamsTaylorN\n(\n\n    \norder\n,\n\n    \nnum_vars\n,\n\n    \nvariable_names\n\n\n)\n\n    defined at\n    \nsrc/parameters.jl:20\n\n\n\n\n\n\n\nHiding 1 method defined outside of this package.\n\n\n\n\nFunctions and methods\n\n\n#\n\n\nTaylorSeries.Taylor1\n \n \nMethod\n.\n\n\nTaylor1(T, [order=1])\nTaylor1([order=1])\n\n\n\n\nShortcut to define the independent variable of a \nTaylor1{T}\n polynomial of given \norder\n. If the type \nT\n is ommitted, \nFloat64\n is assumend.\n\n\nsource\n\n\n#\n\n\nTaylorSeries.TaylorN\n \n \nMethod\n.\n\n\nTaylorN(T, nv; [order=get_order()])\nTaylorN(nv; [order=get_order()])\n\n\n\n\nShortcut to define the \nnv\n-th independent \nTaylorN{T}\n variable as a polynomial. The order is defined through the keyword parameter \norder\n, whose default corresponds to \nget_order()\n. If \nT::Type\n is ommitted, \nFloat64\n is assumend.\n\n\nsource\n\n\n#\n\n\nTaylorSeries.set_variables\n \n \nFunction\n.\n\n\nset_variables(R, names; [order=6])\nset_variables(names; [order=6])\nset_variables(R, names; [order=6, numvars=-1])\nset_variables(names; [order=6, numvars=-1])\n\n\n\n\nReturn a \nTaylorN{R}\n vector with \nnumvars\n polynomials, each representing an independent variable, using \nnames\n as the \nString\n for the output.\n\n\nIf \nnumvars\n is not specified, it is inferred from the length of \nnames\n. If \nlength(names)==1\n and \nnumvars\n1\n, it uses this name with subscripts for the different variables. When changing the \norder\n or \nnumvars\n, the hash_tables are reset.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nset_variables\n{\nT\n<\n:AbstractString\n}\n(\nR\n::\nType\n, \nnames\n::\nArray{T,1}\n)\n\n    defined at\n    \nsrc/parameters.jl:52\n\n\n\n\n\n    \nset_variables\n{\nT\n}\n(\nnames\n::\nArray{T,1}\n)\n\n    defined at\n    \nsrc/parameters.jl:78\n\n\n\n\n\n    \nset_variables\n{\nT\n<\n:AbstractString\n}\n(\nR\n::\nType\n, \nnames\n::\nT\n)\n\n    defined at\n    \nsrc/parameters.jl:81\n\n\n\n\n\n    \nset_variables\n{\nT\n<\n:AbstractString\n}\n(\nnames\n::\nT\n)\n\n    defined at\n    \nsrc/parameters.jl:91\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.show_params_TaylorN\n \n \nFunction\n.\n\n\nshow_params_TaylorN()\n\n\n\n\nDisplay the current parameters for \nTaylorN\n and \nHomogeneousPolynomial\n types.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nshow_params_TaylorN\n(\n)\n\n    defined at\n    \nsrc/parameters.jl:100\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.get_coeff\n \n \nFunction\n.\n\n\nget_coeff(a, n)\n\n\n\n\nReturn the coefficient of order \nn::Int\n of a \na::Taylor1\n polynomial.\n\n\nsource\n\n\nget_coeff(a, v)\n\n\n\n\nReturn the coefficient of \na::HomogeneousPolynomial\n, specified by \nv::Array{Int,1}\n which has the indices of the specific monomial.\n\n\nsource\n\n\nget_coeff(a, v)\n\n\n\n\nReturn the coefficient of \na::TaylorN\n, specified by \nv::Array{Int,1}\n which has the indices of the specific monomial.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nget_coeff\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nn\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:67\n\n\n\n\n\n    \nget_coeff\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nv\n::\nArray{Int64,1}\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:212\n\n\n\n\n\n    \nget_coeff\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nv\n::\nArray{Int64,1}\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:225\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.evaluate\n \n \nFunction\n.\n\n\nevaluate(a, dx)\nevaluate(a)\n\n\n\n\nEvaluate a \nTaylor1\n polynomial using Horner's rule (hand coded). If \ndx\n is ommitted, its value is considered as zero.\n\n\nsource\n\n\nevaluate(a, x)\n\n\n\n\nSubstitute \nx::Taylor1\n as independent variable in a \na::Taylor1\n polynomial.\n\n\nsource\n\n\nevaluate(a, vals)\n\n\n\n\nEvaluate a \nHomogeneousPolynomial\n polynomial using Horner's rule (hand coded) at \nvals\n.\n\n\nsource\n\n\nevaluate(a, [vals])\n\n\n\n\nEvaluate a \nTaylorN\n polynomial using Horner's rule (hand coded) at \nvals\n. If \nvals\n is ommitted, it is evaluated at zero.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nevaluate\n{\nT\n<\n:Number\n, \nS\n<\n:Number\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1{T}\n,\n\n    \nx\n::\nTaylorSeries.Taylor1{S}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:888\n\n\n\n\n\n    \nevaluate\n{\nT\n<\n:Number\n, \nS\n<\n:Number\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1{T}\n,\n\n    \ndx\n::\nS\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:872\n\n\n\n\n\n    \nevaluate\n{\nT\n<\n:Number\n}\n(\na\n::\nTaylorSeries.Taylor1{T}\n)\n\n    defined at\n    \nsrc/Taylor1.jl:879\n\n\n\n\n\n    \nevaluate\n{\nT\n<\n:Number\n, \nS\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial{T}\n,\n\n    \nvals\n::\nArray{S,1}\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:939\n\n\n\n\n\n    \nevaluate\n{\nT\n<\n:Number\n, \nS\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \na\n::\nTaylorSeries.TaylorN{T}\n,\n\n    \nvals\n::\nArray{S,1}\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:960\n\n\n\n\n\n    \nevaluate\n{\nT\n<\n:Number\n}\n(\na\n::\nTaylorSeries.TaylorN{T}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:972\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.derivative\n \n \nFunction\n.\n\n\nderivative(a)\n\n\n\n\nReturn the \nTaylor1\n polynomial of the differential of \na::Taylor1\n. The last coefficient is set to zero.\n\n\nsource\n\n\nderivative(n, a)\n\n\n\n\nReturn the value of the \nn\n-th derivative of the polynomial \na\n.\n\n\nsource\n\n\nderivative(a, r)\n\n\n\n\nPartial differentiation of \na::HomogeneousPolynomial\n series with respect to the \nr\n-th variable.\n\n\nsource\n\n\nderivative(a, [r=1])\n\n\n\n\nPartial differentiation of \na::TaylorN\n series with respect to the \nr\n-th variable.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nderivative\n(\na\n::\nTaylorSeries.Taylor1\n)\n\n    defined at\n    \nsrc/Taylor1.jl:826\n\n\n\n\n\n    \nderivative\n{\nT\n<\n:Number\n}\n(\n\n    \nn\n::\nInt64\n,\n\n    \na\n::\nTaylorSeries.Taylor1{T}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:840\n\n\n\n\n\n    \nderivative\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nr\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:816\n\n\n\n\n\n    \nderivative\n(\na\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:845\n\n\n\n\n\n    \nderivative\n(\na\n::\nTaylorSeries.TaylorN\n, \nr\n)\n\n    defined at\n    \nsrc/TaylorN.jl:845\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.integrate\n \n \nFunction\n.\n\n\nintegrate(a, x)\nintegrate(a)\n\n\n\n\nReturn the integral of \na::Taylor1\n. The constant of integration (0-th order coefficient) is set to \nx\n, which is zero if ommitted.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nintegrate\n{\nT\n<\n:Number\n, \nS\n<\n:Number\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1{T}\n,\n\n    \nx\n::\nS\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:853\n\n\n\n\n\n    \nintegrate\n{\nT\n<\n:Number\n}\n(\na\n::\nTaylorSeries.Taylor1{T}\n)\n\n    defined at\n    \nsrc/Taylor1.jl:861\n\n\n\n\n\n\n\n#\n\n\nBase.LinAlg.gradient\n \n \nFunction\n.\n\n\n    gradient(f)\n    \u2207(f)\n\n\n\n\nCompute the gradient of the polynomial \nf::TaylorN\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ngradient\n(\nf\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:866\n\n\n\n\n\n\n\nHiding 8 methods defined outside of this package.\n\n\n#\n\n\nTaylorSeries.jacobian\n \n \nFunction\n.\n\n\n    jacobian(vf)\n    jacobian(vf, [vals])\n\n\n\n\nCompute the jacobian matrix of \nvf\n, a vector of \nTaylorN\n polynomials, evaluated at the vector \nvals\n. If \nvals\n is ommited, it is evaluated at zero.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \njacobian\n{\nT\n<\n:Number\n}\n(\nvf\n::\nArray{TaylorSeries.TaylorN{T},1}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:886\n\n\n\n\n\n    \njacobian\n{\nT\n<\n:Number\n, \nS\n<\n:Number\n}\n(\n\n    \nvf\n::\nArray{TaylorSeries.TaylorN{T},1}\n,\n\n    \nvals\n::\nArray{S,1}\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:897\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.hessian\n \n \nFunction\n.\n\n\n    hessian(f)\n    hessian(f, [vals])\n\n\n\n\nReturn the hessian matrix (jacobian of the gradient) of \nf::TaylorN\n, evaluated at the vector \nvals\n. If \nvals\n is ommited, it is evaluated at zero.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nhessian\n{\nT\n<\n:Number\n, \nS\n<\n:Number\n}\n(\n\n    \nf\n::\nTaylorSeries.TaylorN{T}\n,\n\n    \nvals\n::\nArray{S,1}\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:923\n\n\n\n\n\n    \nhessian\n{\nT\n<\n:Number\n}\n(\nf\n::\nTaylorSeries.TaylorN{T}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:925\n\n\n\n\n\n\n\n#\n\n\nBase.*\n \n \nFunction\n.\n\n\n*(a, b)\n\n\n\n\nReturn the Taylor expansion of $a \\cdot b$, of order \nmax(a.order,b.order)\n, for \na::Taylor1\n, \nb::Taylor1\n polynomials.\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.mulHomogCoef\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nBool\n,\n\n    \nb\n::\nTaylorSeries.Taylor1\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:193\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nBool\n,\n\n    \nb\n::\nTaylorSeries.HomogeneousPolynomial\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:392\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nBool\n,\n\n    \nb\n::\nTaylorSeries.TaylorN\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:406\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nb\n::\nTaylorSeries.Taylor1\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:215\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nb\n::\nTaylorSeries.HomogeneousPolynomial\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:362\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nb\n::\nTaylorSeries.TaylorN\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:378\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nb\n::\nBool\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:393\n\n\n\n\n\n    \n*\n{\nT\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \nb\n::\nT\n,\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:403\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nb\n::\nBool\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:407\n\n\n\n\n\n    \n*\n{\nT\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \nb\n::\nT\n,\n\n    \na\n::\nTaylorSeries.TaylorN\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:417\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nUnion{Complex,Real}\n,\n\n    \nb\n::\nTaylorSeries.Taylor1\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:196\n\n\n\n\n\n    \n*\n{\nT\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nb\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:395\n\n\n\n\n\n    \n*\n{\nT\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nb\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:409\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nb\n::\nBool\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:194\n\n\n\n\n\n    \n*\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nb\n::\nUnion{Complex,Real}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:203\n\n\n\n\n\n\n\nHiding 150 methods defined outside of this package.\n\n\n#\n\n\nBase./\n \n \nFunction\n.\n\n\n/(a, b)\n\n\n\n\nReturn the Taylor expansion of $a/b$, of order \nmax(a.order,b.order)\n, for \na::Taylor1\n, \nb::Taylor1\n polynomials.\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.divHomogCoef\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \n/\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nb\n::\nTaylorSeries.Taylor1\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:262\n\n\n\n\n\n    \n/\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nb\n::\nTaylorSeries.TaylorN\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:495\n\n\n\n\n\n    \n/\n{\nT\n<\n:Real\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nb\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:249\n\n\n\n\n\n    \n/\n{\nT\n<\n:Complex{T\n<\n:Real}\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nb\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:250\n\n\n\n\n\n    \n/\n{\nT\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nx\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:492\n\n\n\n\n\n    \n/\n{\nT\n<\n:Union{Complex{T\n<\n:Real},Real}\n}\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nx\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:493\n\n\n\n\n\n\n\nHiding 53 methods defined outside of this package.\n\n\n#\n\n\nBase.^\n \n \nFunction\n.\n\n\n^(a, x)\n\n\n\n\nReturn the Taylor expansion of $a^x$ for \na::Taylor1\n polynomial and \nx::Number\n. If \nx\n is non integer and the 0-th order coefficient is zero, an \nArgumentError\n is thrown.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \n^\n{\nT\n<\n:Integer\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nx\n::\nRational{T}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:414\n\n\n\n\n\n    \n^\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nx\n::\nRational\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:615\n\n\n\n\n\n    \n^\n{\nT\n<\n:Integer\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1{T}\n,\n\n    \nn\n::\nInteger\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:380\n\n\n\n\n\n    \n^\n{\nT\n<\n:Number\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1{T}\n,\n\n    \nn\n::\nInteger\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:372\n\n\n\n\n\n    \n^\n(\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nn\n::\nInteger\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:561\n\n\n\n\n\n    \n^\n{\nT\n<\n:Integer\n}\n(\n\n    \na\n::\nTaylorSeries.TaylorN{T}\n,\n\n    \nn\n::\nInteger\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:577\n\n\n\n\n\n    \n^\n{\nT\n<\n:Number\n}\n(\n\n    \na\n::\nTaylorSeries.TaylorN{T}\n,\n\n    \nn\n::\nInteger\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:569\n\n\n\n\n\n    \n^\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nb\n::\nTaylorSeries.Taylor1\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:416\n\n\n\n\n\n    \n^\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nb\n::\nTaylorSeries.TaylorN\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:617\n\n\n\n\n\n    \n^\n{\nS\n<\n:Real\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nx\n::\nS\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:420\n\n\n\n\n\n    \n^\n{\nT\n<\n:Complex{T\n<\n:Real}\n}\n(\n\n    \na\n::\nTaylorSeries.Taylor1\n,\n\n    \nx\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:451\n\n\n\n\n\n    \n^\n{\nS\n<\n:Real\n}\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nx\n::\nS\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:621\n\n\n\n\n\n    \n^\n{\nT\n<\n:Complex{T\n<\n:Real}\n}\n(\n\n    \na\n::\nTaylorSeries.TaylorN\n,\n\n    \nx\n::\nT\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:645\n\n\n\n\n\n\n\nHiding 46 methods defined outside of this package.\n\n\n#\n\n\nBase.sqrt\n \n \nFunction\n.\n\n\nsqrt(a)\n\n\n\n\nReturn  the Taylor expansion of $\\sqrt(a)$, of order \na.order\n, for \na::Taylor1\n polynomial. If the first non-vanishing coefficient of \na\n is an odd power, and \nArgumentError\n is thrown.\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.sqrtHomogCoef\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsqrt\n(\na\n::\nTaylorSeries.Taylor1\n)\n\n    defined at\n    \nsrc/Taylor1.jl:539\n\n\n\n\n\n    \nsqrt\n(\na\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:685\n\n\n\n\n\n\n\nHiding 12 methods defined outside of this package.\n\n\n#\n\n\nBase.exp\n \n \nFunction\n.\n\n\nexp(a)\n\n\n\n\nReturn the Taylor expansion of $e^a$, of order \na.order\n, for \na::Taylor1\n polynomial.\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.expHomogCoef\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nexp\n(\na\n::\nTaylorSeries.Taylor1\n)\n\n    defined at\n    \nsrc/Taylor1.jl:611\n\n\n\n\n\n    \nexp\n(\na\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:716\n\n\n\n\n\n\n\nHiding 13 methods defined outside of this package.\n\n\n#\n\n\nBase.log\n \n \nFunction\n.\n\n\nlog(a)\n\n\n\n\nReturn the Taylor expansion of $\\log(a)$, of order \na.order\n, for \na::Taylor1\n polynomial.\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.logHomogCoef\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nlog\n(\na\n::\nTaylorSeries.Taylor1\n)\n\n    defined at\n    \nsrc/Taylor1.jl:656\n\n\n\n\n\n    \nlog\n(\na\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:735\n\n\n\n\n\n\n\nHiding 20 methods defined outside of this package.\n\n\n#\n\n\nBase.sin\n \n \nFunction\n.\n\n\nsin(a)\n\n\n\n\nReturn the Taylor expansion of $\\sin(a)$, of order \na.order\n, for \na::Taylor1\n polynomial.\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.sincosHomogCoef\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsin\n(\na\n::\nTaylorSeries.Taylor1\n)\n\n    defined at\n    \nsrc/Taylor1.jl:703\n\n\n\n\n\n    \nsin\n(\na\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:759\n\n\n\n\n\n\n\nHiding 12 methods defined outside of this package.\n\n\n#\n\n\nBase.cos\n \n \nFunction\n.\n\n\ncos(a)\n\n\n\n\nReturn the Taylor expansion of $\\cos(a)$, of order \na.order\n, for \na::Taylor1\n polynomial\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.sincosHomogCoef\n..\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ncos\n(\na\n::\nTaylorSeries.Taylor1\n)\n\n    defined at\n    \nsrc/Taylor1.jl:714\n\n\n\n\n\n    \ncos\n(\na\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:760\n\n\n\n\n\n\n\nHiding 12 methods defined outside of this package.\n\n\n#\n\n\nBase.tan\n \n \nFunction\n.\n\n\ntan(a)\n\n\n\n\nReturn the Taylor expansion of $\\tan(a)$, of order \na.order\n, for \na::Taylor1\n polynomial.\n\n\nFor details on making the Taylor expansion, see \nTaylorSeries.tanHomogCoef\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ntan\n(\na\n::\nTaylorSeries.Taylor1\n)\n\n    defined at\n    \nsrc/Taylor1.jl:778\n\n\n\n\n\n    \ntan\n(\na\n::\nTaylorSeries.TaylorN\n)\n\n    defined at\n    \nsrc/TaylorN.jl:788\n\n\n\n\n\n\n\nHiding 12 methods defined outside of this package.\n\n\n#\n\n\nBase.abs\n \n \nFunction\n.\n\n\nabs(a)\n\n\n\n\nReturn \na\n or \n-a\n depending on the 0-th order coefficient of the \nTaylor1\n polynomial \na\n. If \na.coeffs[1]\n is zero, an \nArgumentError\n is thrown.\n\n\nsource\n\n\nabs(a::TaylorN)\n\n\n\n\nAbsolute value of a \nTaylorN\n polynomial, using the 0-th order coefficient.\n\n\nReturn \na\n or \n-a\n, depending on the 0-th order coefficient of \na\n. If it is zero, it throws an \nArgumentError\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nabs\n{\nT\n<\n:Real\n}\n(\na\n::\nTaylorSeries.Taylor1{T}\n)\n\n    defined at\n    \nsrc/Taylor1.jl:350\n\n\n\n\n\n    \nabs\n{\nT\n<\n:Real\n}\n(\na\n::\nTaylorSeries.TaylorN{T}\n)\n\n    defined at\n    \nsrc/TaylorN.jl:548\n\n\n\n\n\n\n\nHiding 30 methods defined outside of this package.\n\n\n\n\nInternals\n\n\n#\n\n\nTaylorSeries.generate_tables\n \n \nFunction\n.\n\n\ngenerate_tables(num_vars, order)\n\n\n\n\nReturn the hash tables \ncoeff_table\n, \nindex_table\n, \nsize_table\n and \npos_table\n. Internally, these are treated as \nconst\n.\n\n\nHash tables\n\n\ncoeff_table :: Array{Array{Array{Int64,1},1},1}\n\n\n\n\nThe $i+1$-th component contains a vector with the vectors of all the possible combinations of monomials of a \nHomogeneousPolynomial\n of order $i$.\n\n\nindex_table :: Array{Array{Int64,1},1}\n\n\n\n\nThe $i+1$-th component contains a vector of (hashed) indices that represent the distinct monomials of a \nHomogeneousPolynomial\n of order (degree) $i$.\n\n\nsize_table :: Array{Int64,1}\n\n\n\n\nThe $i+1$-th component contains the number of distinct monomials of the \nHomogeneousPolynomial\n of order $i$, equivalent to \nlength(coeff_table[i])\n.\n\n\npos_table :: Array{Dict{Int64,Int64},1}\n\n\n\n\nThe $i+1$-th component maps the hash index to the (lexicographic) position of the corresponding monomial in \ncoeffs_table\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ngenerate_tables\n(\nnum_vars\n, \norder\n)\n\n    defined at\n    \nsrc/hash_tables.jl:34\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.generate_index_vectors\n \n \nFunction\n.\n\n\ngenerate_index_vectors(num_vars, degree)\n\n\n\n\nReturn a vector of index vectors with \nnum_vars\n (number of variables) and degree.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ngenerate_index_vectors\n(\nnum_vars\n, \ndegree\n)\n\n    defined at\n    \nsrc/hash_tables.jl:51\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.in_base\n \n \nFunction\n.\n\n\nin_base(order, v)\n\n\n\n\nConvert vector \nv\n of non-negative integers to base \norder+1\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nin_base\n(\norder\n, \nv\n)\n\n    defined at\n    \nsrc/hash_tables.jl:90\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.make_inverse_dict\n \n \nFunction\n.\n\n\nmake_inverse_dict(v)\n\n\n\n\nReturn a Dict with the enumeration of \nv\n: the elements of \nv\n point to the corresponding index.\n\n\nIt is used to construct \npos_table\n from \nindex_table\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmake_inverse_dict\n(\nv\n::\nArray{T\n<\n:Any,1}\n)\n\n    defined at\n    \nsrc/hash_tables.jl:81\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.order_posTb\n \n \nFunction\n.\n\n\norder_posTb(order, nv, ord)\n\n\n\n\nReturn a vector with the positions, in a \nHomogeneousPolynomial\n of order \norder\n, where the variable \nnv\n has order \nord\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \norder_posTb\n(\n\n    \norder\n::\nInt64\n,\n\n    \nnv\n::\nInt64\n,\n\n    \nord\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:1033\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.mul!\n \n \nFunction\n.\n\n\nmul!(c, a, b)\n\n\n\n\nReturn \nc = a*b\n with no allocation; all parameters are \nHomogeneousPolynomial\n.\n\n\nsource\n\n\nmul!(c, a)\n\n\n\n\nReturn \nc = a*a\n with no allocation; all parameters are \nHomogeneousPolynomial\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmul!\n(\n\n    \nc\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:462\n\n\n\n\n\n    \nmul!\n(\n\n    \nc\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \na\n::\nTaylorSeries.HomogeneousPolynomial\n,\n\n    \nb\n::\nTaylorSeries.HomogeneousPolynomial\n\n\n)\n\n    defined at\n    \nsrc/TaylorN.jl:428\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.mulHomogCoef\n \n \nFunction\n.\n\n\nmulHomogCoef(kcoef, ac, bc)\n\n\n\n\nCompute the \nk\n-th expansion coefficient of $c = a\\cdot b$ given by\n\n\n\n\n\\begin{equation*} c_k = \\sum_{j=0}^k a_j b_{k-j}, \\end{equation*}\n\n\n\n\nwith $a$ and $b$ \nTaylor1\n polynomials.\n\n\nInputs are the \nkcoef\n-th coefficient, and the vectors of the expansion coefficients \nac\n and \nbc\n, corresponding respectively to \na\n and \nb\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nmulHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \nbc\n::\nArray{T,1}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:240\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.divHomogCoef\n \n \nFunction\n.\n\n\ndivHomogCoef(kcoef, ac, bc, coeffs, ordfact)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $c = a / b$ given by\n\n\n\n\n\\begin{equation*} c_k =  \\frac{1}{b_0} (a_k - \\sum_{j=0}^{k-1} c_j b_{k-j}), \\end{equation*}\n\n\n\n\nwith $a$ and $b$ \nTaylor1\n polynomials.\n\n\nInputs are the \nkcoef\n-th coefficient, the vectors of the expansion coefficients \nac\n and \nbc\n, corresponding respectively to \na\n and \nb\n, the already calculated expansion coefficients \ncoeffs\n of \nc\n, and \nordfact\n which is the order of the factorized term of the denominator, whenever \nb_0\n is zero.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ndivHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \nbc\n::\nArray{T,1}\n,\n\n    \ncoeffs\n::\nArray{T,1}\n,\n\n    \nordfact\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:318\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.powHomogCoef\n \n \nFunction\n.\n\n\npowHomogCoef(kcoef, ac, x, coeffs, knull)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $c = a^x$, given by\n\n\n\n\n\\begin{equation*} c_k = \\frac{1}{k a_0} \\sum_{j=0}^{k-1} ((k-j)x -j) - j)a_{k-j} c_j, \\end{equation*}\n\n\n\n\nwith $a$ a \nTaylor1\n polynomial, and \nx\n a number.\n\n\nInputs are the \nkcoef\n-th coefficient, the vector of the expansion coefficients \nac\n of \na\n, the exponent \nx\n, the already calculated expansion coefficients \ncoeffs\n of \nc\n, and \nknull\n which is the order of the first non-zero coefficient of \na\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \npowHomogCoef\n{\nT\n<\n:Number\n, \nS\n<\n:Real\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \nx\n::\nS\n,\n\n    \ncoeffs\n::\nArray{T,1}\n,\n\n    \nknull\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:473\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.squareHomogCoef\n \n \nFunction\n.\n\n\nsquareHomogCoef(kcoef, ac)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $c = a^2$, given by\n\n\n\n\n\\begin{eqnarray*} c_k &=& 2 \\sum_{j=0}^{(k-1)/2} a_{k-j} a_j, \\text{ if $k$ is odd, or }  \\\\\nc_k &=& 2 \\sum_{j=0}^{(k-2)/2} a_{k-j} a_j + (a_{k/2})^2, \\text{ if $k$ is even, } \\end{eqnarray*}\n\n\n\n\nwith $a$ a \nTaylor1\n polynomial.\n\n\nInputs are the \nkcoef\n-th coefficient and the vector of the expansion coefficients \nac\n of \na\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsquareHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:512\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.sqrtHomogCoef\n \n \nFunction\n.\n\n\nsqrtHomogCoef(kcoef, ac, coeffs, knull)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $c = \\sqrt(a)$, given by\n\n\n\n\n\\begin{eqnarray*} c_k &=& \\frac{1}{2 c_0} ( a_k - 2\u00a0\\sum_{j=0}^{(k-1)/2} c_{k-j}c_j), \\text{ if $k$ is odd, or } \\\\\nc_k &=& \\frac{1}{2 c_0} ( a_k - 2 \\sum_{j=0}^{(k-2)/2} c_{k-j}c_j) - (c_{k/2})^2, \\text{ if $k$ is even,} \\end{eqnarray*}\n\n\n\n\nwith $a$ a \nTaylor1\n polynomial.\n\n\nInputs are the \nkcoef\n-th coefficient, the vector of the expansion coefficients \nac\n of \na\n, the already calculated expansion coefficients \ncoeffs\n of \nc\n, and \nknull\n, which is half of the order of the first non-zero coefficient of \na\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsqrtHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \ncoeffs\n::\nArray{T,1}\n,\n\n    \nknull\n::\nInt64\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:583\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.expHomogCoef\n \n \nFunction\n.\n\n\nexpHomogCoef(kcoef, ac, coeffs)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $c = \\exp(a)$ given by\n\n\n\n\n\\begin{equation*} c_k = \\frac{1}{k} \\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j, \\end{equation*}\n\n\n\n\nwith $a$ a \nTaylor1\n polynomial.\n\n\nInputs are the \nkcoef\n-th coefficient, the vector of the expansion coefficients \nac\n of $a$, and the already calculated expansion coefficients \ncoeffs\n of \nc\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nexpHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \ncoeffs\n::\nArray{T,1}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:638\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.logHomogCoef\n \n \nFunction\n.\n\n\nlogHomogCoef(kcoef, ac, coeffs)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $c = \\log(a)$, given by\n\n\n\n\n\\begin{equation*} c_k = \\frac{1}{a_0} (a_k - \\frac{1}{k} \\sum_{j=0}^{k-1} j a_{k-j} c_j ), \\end{equation*}\n\n\n\n\nwith $a$ a \nTaylor1\n polynomial.\n\n\nInputs are the \nkcoef\n-th coefficient, the vector of the expansion coefficients \nac\n of \na\n, and the already calculated expansion coefficients \ncoeffs\n of \nc\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nlogHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \ncoeffs\n::\nArray{T,1}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:685\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.sincosHomogCoef\n \n \nFunction\n.\n\n\nsincosHomogCoef(kcoef, ac, scoeffs, ccoeffs)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $s = \\sin(a)$ and $c=\\cos(a)$ simultaneously given by\n\n\n\n\n\\begin{eqnarray*} s_k &=& \\frac{1}{k} \\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j \\\\ \\\n c_k &=& -\\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) a_{k-j} s_j \\end{eqnarray*}\n\n\n\n\nwith $a$ a \nTaylor1\n polynomial.\n\n\nInputs are the \nkcoef\n-th coefficient, the vector of the expansion coefficients \nac\n of \na\n, and the already calculated expansion coefficients \nscoeffs\n and \nccoeffs\n of \nsin(a)\n and \ncos(a)\n, respectvely.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nsincosHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \nscoeffs\n::\nArray{T,1}\n,\n\n    \nccoeffs\n::\nArray{T,1}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:753\n\n\n\n\n\n\n\n#\n\n\nTaylorSeries.tanHomogCoef\n \n \nFunction\n.\n\n\ntanHomogCoef(kcoef, ac, coeffst2)\n\n\n\n\nCompute the \nk-th\n expansion coefficient of $c = \\tan(a)$ given by\n\n\n\n\n\\begin{equation*} c_k = a_k + \\frac{1}{k} \\sum_{j=0}^{k-1} (k-j) a_{k-j} p_j, \\end{equation*}\n\n\n\n\nwith $a$ a \nTaylor1\n polynomial and $p = c^2$.\n\n\nInputs are the \nkcoef\n-th coefficient, the vector of the expansion coefficients \nac\n of \na\n, and the already calculated expansion coefficients \ncoeffst2\n of \nc^2\n.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \ntanHomogCoef\n{\nT\n<\n:Number\n}\n(\n\n    \nkcoef\n::\nInt64\n,\n\n    \nac\n::\nArray{T,1}\n,\n\n    \ncoeffst2\n::\nArray{T,1}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:809\n\n\n\n\n\n\n\n#\n\n\nBase.LinAlg.A_mul_B!\n \n \nFunction\n.\n\n\nA_mul_B!(Y, A, B)\n\n\n\n\nMultiply A*B and save the result in Y.\n\n\nsource\n\n\nMethods\n\n\n\n\n\n    \nA_mul_B!\n{\nT\n<\n:Number\n}\n(\n\n    \ny\n::\nArray{TaylorSeries.Taylor1{T},1}\n,\n\n    \na\n::\nUnion{Array{T,2},SparseMatrixCSC{T,Ti\n<\n:Integer}}\n,\n\n    \nb\n::\nArray{TaylorSeries.Taylor1{T},1}\n\n\n)\n\n    defined at\n    \nsrc/Taylor1.jl:905\n\n\n\n\n\n\n\nHiding 91 methods defined outside of this package.", 
            "title": "API"
        }, 
        {
            "location": "/api/#library", 
            "text": "", 
            "title": "Library"
        }, 
        {
            "location": "/api/#types", 
            "text": "#  TaylorSeries.Taylor1     Type .  Taylor1{T :Number}  : Number  DataType for polynomial expansions in one independent variable.  Fields:   coeffs :: Array{T,1}  Expansion coefficients; the $i$-th component is the coefficient of degree $i-1$ of the expansion.  order  :: Int64  Maximum order (degree) of the polynomial.   source  Taylor1(T, [order=1])\nTaylor1([order=1])  Shortcut to define the independent variable of a  Taylor1{T}  polynomial of given  order . If the type  T  is ommitted,  Float64  is assumend.  source  Methods   \n     Taylor1 ( ) \n    defined at\n     src/Taylor1.jl:59   \n     Taylor1 { T < :Number } ( coeffs :: Array{T,1} ) \n    defined at\n     src/Taylor1.jl:46   \n     Taylor1 { T < :Number } ( \n     x :: TaylorSeries.Taylor1{T} ,      order :: Int64  ) \n    defined at\n     src/Taylor1.jl:43   \n     Taylor1 { T < :Number } ( x :: TaylorSeries.Taylor1{T} ) \n    defined at\n     src/Taylor1.jl:44   \n     Taylor1 { T < :Number } ( \n     coeffs :: Array{T,1} ,      order :: Int64  ) \n    defined at\n     src/Taylor1.jl:45   \n     Taylor1 ( order :: Int64 ) \n    defined at\n     src/Taylor1.jl:59   \n     Taylor1 { T < :Number } ( x :: T ,  order :: Int64 ) \n    defined at\n     src/Taylor1.jl:47   \n     Taylor1 { T < :Number } ( :: Type{T} ) \n    defined at\n     src/Taylor1.jl:58   \n     Taylor1 { T < :Number } ( :: Type{T} ,  order :: Int64 ) \n    defined at\n     src/Taylor1.jl:58    Hiding 1 method defined outside of this package.  #  TaylorSeries.HomogeneousPolynomial     Type .  HomogeneousPolynomial{T :Number}  : Number  DataType for homogenous polynomials in many ( 1) independent variables.  Fields:   coeffs  :: Array{T,1}  Expansion coefficients of the homogeneous polynomial; the $i$-th component is related to a monomial, where the degrees of the independent variables are specified by  coeff_table[order+1][i] .  order   :: Int  order (degree) of the homogenous polynomial.   source  Methods   \n     HomogeneousPolynomial { T < :Number } ( coeffs :: Array{T,1} ) \n    defined at\n     src/TaylorN.jl:56   \n     HomogeneousPolynomial { T < :Number } ( \n     x :: TaylorSeries.HomogeneousPolynomial{T} ,      order :: Int64  ) \n    defined at\n     src/TaylorN.jl:51   \n     HomogeneousPolynomial { T < :Number } ( x :: TaylorSeries.HomogeneousPolynomial{T} ) \n    defined at\n     src/TaylorN.jl:53   \n     HomogeneousPolynomial { T < :Number } ( \n     coeffs :: Array{T,1} ,      order :: Int64  ) \n    defined at\n     src/TaylorN.jl:54   \n     HomogeneousPolynomial { T < :Number } ( x :: T ,  order :: Int64 ) \n    defined at\n     src/TaylorN.jl:58   \n     HomogeneousPolynomial { T < :Number } ( x :: T ) \n    defined at\n     src/TaylorN.jl:60    Hiding 1 method defined outside of this package.  #  TaylorSeries.TaylorN     Type .  TaylorN{T :Number}  : Number  DataType for polynomial expansions in many ( 1) independent variables.  Fields:   coeffs  :: Array{HomogeneousPolynomial{T},1}  Vector containing the  HomogeneousPolynomial  entries. The $i$-th component corresponds to the homogeneous polynomial of degree $i-1$.  order   :: Int   maximum order of the polynomial expansion.   source  TaylorN(T, nv; [order=get_order()])\nTaylorN(nv; [order=get_order()])  Shortcut to define the  nv -th independent  TaylorN{T}  variable as a polynomial. The order is defined through the keyword parameter  order , whose default corresponds to  get_order() . If  T::Type  is ommitted,  Float64  is assumend.  source  Methods   \n     TaylorN { T < :Number } ( x :: Array{TaylorSeries.HomogeneousPolynomial{T},1} ) \n    defined at\n     src/TaylorN.jl:177   \n     TaylorN { T < :Number } ( \n     x :: TaylorSeries.TaylorN{T} ,      order :: Int64  ) \n    defined at\n     src/TaylorN.jl:173   \n     TaylorN { T < :Number } ( x :: TaylorSeries.TaylorN{T} ) \n    defined at\n     src/TaylorN.jl:174   \n     TaylorN { T < :Number } ( \n     x :: Array{TaylorSeries.HomogeneousPolynomial{T},1} ,      order :: Int64  ) \n    defined at\n     src/TaylorN.jl:175   \n     TaylorN { T < :Number } ( \n     x :: TaylorSeries.HomogeneousPolynomial{T} ,      order :: Int64  ) \n    defined at\n     src/TaylorN.jl:178   \n     TaylorN { T < :Number } ( x :: TaylorSeries.HomogeneousPolynomial{T} ) \n    defined at\n     src/TaylorN.jl:180   \n     TaylorN ( nv :: Int64 ) \n    defined at\n     src/TaylorN.jl:201   \n     TaylorN { T < :Number } ( x :: T ,  order :: Int64 ) \n    defined at\n     src/TaylorN.jl:181   \n     TaylorN { T < :Number } ( :: Type{T} ,  nv :: Int64 ) \n    defined at\n     src/TaylorN.jl:196    Hiding 1 method defined outside of this package.  #  TaylorSeries.ParamsTaylorN     Type .  ParamsTaylorN  DataType holding the current parameters for  TaylorN  and  HomogeneousPolynomial .  Fields:   order          :: Int   Order (degree) of the polynomials  num_vars       :: Int   Number of variables  variable_names :: Array{String,1}  Name of the variables   These parameters can be changed using  set_params_TaylorN(order, numVars) .  source  Methods   \n     ParamsTaylorN ( \n     order :: Int64 ,      num_vars :: Int64 ,      variable_names :: Array{String,1}  ) \n    defined at\n     src/parameters.jl:20   \n     ParamsTaylorN ( \n     order ,      num_vars ,      variable_names  ) \n    defined at\n     src/parameters.jl:20    Hiding 1 method defined outside of this package.", 
            "title": "Types"
        }, 
        {
            "location": "/api/#functions-and-methods", 
            "text": "#  TaylorSeries.Taylor1     Method .  Taylor1(T, [order=1])\nTaylor1([order=1])  Shortcut to define the independent variable of a  Taylor1{T}  polynomial of given  order . If the type  T  is ommitted,  Float64  is assumend.  source  #  TaylorSeries.TaylorN     Method .  TaylorN(T, nv; [order=get_order()])\nTaylorN(nv; [order=get_order()])  Shortcut to define the  nv -th independent  TaylorN{T}  variable as a polynomial. The order is defined through the keyword parameter  order , whose default corresponds to  get_order() . If  T::Type  is ommitted,  Float64  is assumend.  source  #  TaylorSeries.set_variables     Function .  set_variables(R, names; [order=6])\nset_variables(names; [order=6])\nset_variables(R, names; [order=6, numvars=-1])\nset_variables(names; [order=6, numvars=-1])  Return a  TaylorN{R}  vector with  numvars  polynomials, each representing an independent variable, using  names  as the  String  for the output.  If  numvars  is not specified, it is inferred from the length of  names . If  length(names)==1  and  numvars 1 , it uses this name with subscripts for the different variables. When changing the  order  or  numvars , the hash_tables are reset.  source  Methods   \n     set_variables { T < :AbstractString } ( R :: Type ,  names :: Array{T,1} ) \n    defined at\n     src/parameters.jl:52   \n     set_variables { T } ( names :: Array{T,1} ) \n    defined at\n     src/parameters.jl:78   \n     set_variables { T < :AbstractString } ( R :: Type ,  names :: T ) \n    defined at\n     src/parameters.jl:81   \n     set_variables { T < :AbstractString } ( names :: T ) \n    defined at\n     src/parameters.jl:91    #  TaylorSeries.show_params_TaylorN     Function .  show_params_TaylorN()  Display the current parameters for  TaylorN  and  HomogeneousPolynomial  types.  source  Methods   \n     show_params_TaylorN ( ) \n    defined at\n     src/parameters.jl:100    #  TaylorSeries.get_coeff     Function .  get_coeff(a, n)  Return the coefficient of order  n::Int  of a  a::Taylor1  polynomial.  source  get_coeff(a, v)  Return the coefficient of  a::HomogeneousPolynomial , specified by  v::Array{Int,1}  which has the indices of the specific monomial.  source  get_coeff(a, v)  Return the coefficient of  a::TaylorN , specified by  v::Array{Int,1}  which has the indices of the specific monomial.  source  Methods   \n     get_coeff ( \n     a :: TaylorSeries.Taylor1 ,      n :: Int64  ) \n    defined at\n     src/Taylor1.jl:67   \n     get_coeff ( \n     a :: TaylorSeries.HomogeneousPolynomial ,      v :: Array{Int64,1}  ) \n    defined at\n     src/TaylorN.jl:212   \n     get_coeff ( \n     a :: TaylorSeries.TaylorN ,      v :: Array{Int64,1}  ) \n    defined at\n     src/TaylorN.jl:225    #  TaylorSeries.evaluate     Function .  evaluate(a, dx)\nevaluate(a)  Evaluate a  Taylor1  polynomial using Horner's rule (hand coded). If  dx  is ommitted, its value is considered as zero.  source  evaluate(a, x)  Substitute  x::Taylor1  as independent variable in a  a::Taylor1  polynomial.  source  evaluate(a, vals)  Evaluate a  HomogeneousPolynomial  polynomial using Horner's rule (hand coded) at  vals .  source  evaluate(a, [vals])  Evaluate a  TaylorN  polynomial using Horner's rule (hand coded) at  vals . If  vals  is ommitted, it is evaluated at zero.  source  Methods   \n     evaluate { T < :Number ,  S < :Number } ( \n     a :: TaylorSeries.Taylor1{T} ,      x :: TaylorSeries.Taylor1{S}  ) \n    defined at\n     src/Taylor1.jl:888   \n     evaluate { T < :Number ,  S < :Number } ( \n     a :: TaylorSeries.Taylor1{T} ,      dx :: S  ) \n    defined at\n     src/Taylor1.jl:872   \n     evaluate { T < :Number } ( a :: TaylorSeries.Taylor1{T} ) \n    defined at\n     src/Taylor1.jl:879   \n     evaluate { T < :Number ,  S < :Union{Complex{T < :Real},Real} } ( \n     a :: TaylorSeries.HomogeneousPolynomial{T} ,      vals :: Array{S,1}  ) \n    defined at\n     src/TaylorN.jl:939   \n     evaluate { T < :Number ,  S < :Union{Complex{T < :Real},Real} } ( \n     a :: TaylorSeries.TaylorN{T} ,      vals :: Array{S,1}  ) \n    defined at\n     src/TaylorN.jl:960   \n     evaluate { T < :Number } ( a :: TaylorSeries.TaylorN{T} ) \n    defined at\n     src/TaylorN.jl:972    #  TaylorSeries.derivative     Function .  derivative(a)  Return the  Taylor1  polynomial of the differential of  a::Taylor1 . The last coefficient is set to zero.  source  derivative(n, a)  Return the value of the  n -th derivative of the polynomial  a .  source  derivative(a, r)  Partial differentiation of  a::HomogeneousPolynomial  series with respect to the  r -th variable.  source  derivative(a, [r=1])  Partial differentiation of  a::TaylorN  series with respect to the  r -th variable.  source  Methods   \n     derivative ( a :: TaylorSeries.Taylor1 ) \n    defined at\n     src/Taylor1.jl:826   \n     derivative { T < :Number } ( \n     n :: Int64 ,      a :: TaylorSeries.Taylor1{T}  ) \n    defined at\n     src/Taylor1.jl:840   \n     derivative ( \n     a :: TaylorSeries.HomogeneousPolynomial ,      r :: Int64  ) \n    defined at\n     src/TaylorN.jl:816   \n     derivative ( a :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:845   \n     derivative ( a :: TaylorSeries.TaylorN ,  r ) \n    defined at\n     src/TaylorN.jl:845    #  TaylorSeries.integrate     Function .  integrate(a, x)\nintegrate(a)  Return the integral of  a::Taylor1 . The constant of integration (0-th order coefficient) is set to  x , which is zero if ommitted.  source  Methods   \n     integrate { T < :Number ,  S < :Number } ( \n     a :: TaylorSeries.Taylor1{T} ,      x :: S  ) \n    defined at\n     src/Taylor1.jl:853   \n     integrate { T < :Number } ( a :: TaylorSeries.Taylor1{T} ) \n    defined at\n     src/Taylor1.jl:861    #  Base.LinAlg.gradient     Function .      gradient(f)\n    \u2207(f)  Compute the gradient of the polynomial  f::TaylorN .  source  Methods   \n     gradient ( f :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:866    Hiding 8 methods defined outside of this package.  #  TaylorSeries.jacobian     Function .      jacobian(vf)\n    jacobian(vf, [vals])  Compute the jacobian matrix of  vf , a vector of  TaylorN  polynomials, evaluated at the vector  vals . If  vals  is ommited, it is evaluated at zero.  source  Methods   \n     jacobian { T < :Number } ( vf :: Array{TaylorSeries.TaylorN{T},1} ) \n    defined at\n     src/TaylorN.jl:886   \n     jacobian { T < :Number ,  S < :Number } ( \n     vf :: Array{TaylorSeries.TaylorN{T},1} ,      vals :: Array{S,1}  ) \n    defined at\n     src/TaylorN.jl:897    #  TaylorSeries.hessian     Function .      hessian(f)\n    hessian(f, [vals])  Return the hessian matrix (jacobian of the gradient) of  f::TaylorN , evaluated at the vector  vals . If  vals  is ommited, it is evaluated at zero.  source  Methods   \n     hessian { T < :Number ,  S < :Number } ( \n     f :: TaylorSeries.TaylorN{T} ,      vals :: Array{S,1}  ) \n    defined at\n     src/TaylorN.jl:923   \n     hessian { T < :Number } ( f :: TaylorSeries.TaylorN{T} ) \n    defined at\n     src/TaylorN.jl:925    #  Base.*     Function .  *(a, b)  Return the Taylor expansion of $a \\cdot b$, of order  max(a.order,b.order) , for  a::Taylor1 ,  b::Taylor1  polynomials.  For details on making the Taylor expansion, see  TaylorSeries.mulHomogCoef .  source  Methods   \n     * ( \n     a :: Bool ,      b :: TaylorSeries.Taylor1  ) \n    defined at\n     src/Taylor1.jl:193   \n     * ( \n     a :: Bool ,      b :: TaylorSeries.HomogeneousPolynomial  ) \n    defined at\n     src/TaylorN.jl:392   \n     * ( \n     a :: Bool ,      b :: TaylorSeries.TaylorN  ) \n    defined at\n     src/TaylorN.jl:406   \n     * ( \n     a :: TaylorSeries.Taylor1 ,      b :: TaylorSeries.Taylor1  ) \n    defined at\n     src/Taylor1.jl:215   \n     * ( \n     a :: TaylorSeries.HomogeneousPolynomial ,      b :: TaylorSeries.HomogeneousPolynomial  ) \n    defined at\n     src/TaylorN.jl:362   \n     * ( \n     a :: TaylorSeries.TaylorN ,      b :: TaylorSeries.TaylorN  ) \n    defined at\n     src/TaylorN.jl:378   \n     * ( \n     a :: TaylorSeries.HomogeneousPolynomial ,      b :: Bool  ) \n    defined at\n     src/TaylorN.jl:393   \n     * { T < :Union{Complex{T < :Real},Real} } ( \n     b :: T ,      a :: TaylorSeries.HomogeneousPolynomial  ) \n    defined at\n     src/TaylorN.jl:403   \n     * ( \n     a :: TaylorSeries.TaylorN ,      b :: Bool  ) \n    defined at\n     src/TaylorN.jl:407   \n     * { T < :Union{Complex{T < :Real},Real} } ( \n     b :: T ,      a :: TaylorSeries.TaylorN  ) \n    defined at\n     src/TaylorN.jl:417   \n     * ( \n     a :: Union{Complex,Real} ,      b :: TaylorSeries.Taylor1  ) \n    defined at\n     src/Taylor1.jl:196   \n     * { T < :Union{Complex{T < :Real},Real} } ( \n     a :: TaylorSeries.HomogeneousPolynomial ,      b :: T  ) \n    defined at\n     src/TaylorN.jl:395   \n     * { T < :Union{Complex{T < :Real},Real} } ( \n     a :: TaylorSeries.TaylorN ,      b :: T  ) \n    defined at\n     src/TaylorN.jl:409   \n     * ( \n     a :: TaylorSeries.Taylor1 ,      b :: Bool  ) \n    defined at\n     src/Taylor1.jl:194   \n     * ( \n     a :: TaylorSeries.Taylor1 ,      b :: Union{Complex,Real}  ) \n    defined at\n     src/Taylor1.jl:203    Hiding 150 methods defined outside of this package.  #  Base./     Function .  /(a, b)  Return the Taylor expansion of $a/b$, of order  max(a.order,b.order) , for  a::Taylor1 ,  b::Taylor1  polynomials.  For details on making the Taylor expansion, see  TaylorSeries.divHomogCoef .  source  Methods   \n     / ( \n     a :: TaylorSeries.Taylor1 ,      b :: TaylorSeries.Taylor1  ) \n    defined at\n     src/Taylor1.jl:262   \n     / ( \n     a :: TaylorSeries.TaylorN ,      b :: TaylorSeries.TaylorN  ) \n    defined at\n     src/TaylorN.jl:495   \n     / { T < :Real } ( \n     a :: TaylorSeries.Taylor1 ,      b :: T  ) \n    defined at\n     src/Taylor1.jl:249   \n     / { T < :Complex{T < :Real} } ( \n     a :: TaylorSeries.Taylor1 ,      b :: T  ) \n    defined at\n     src/Taylor1.jl:250   \n     / { T < :Union{Complex{T < :Real},Real} } ( \n     a :: TaylorSeries.HomogeneousPolynomial ,      x :: T  ) \n    defined at\n     src/TaylorN.jl:492   \n     / { T < :Union{Complex{T < :Real},Real} } ( \n     a :: TaylorSeries.TaylorN ,      x :: T  ) \n    defined at\n     src/TaylorN.jl:493    Hiding 53 methods defined outside of this package.  #  Base.^     Function .  ^(a, x)  Return the Taylor expansion of $a^x$ for  a::Taylor1  polynomial and  x::Number . If  x  is non integer and the 0-th order coefficient is zero, an  ArgumentError  is thrown.  source  Methods   \n     ^ { T < :Integer } ( \n     a :: TaylorSeries.Taylor1 ,      x :: Rational{T}  ) \n    defined at\n     src/Taylor1.jl:414   \n     ^ ( \n     a :: TaylorSeries.TaylorN ,      x :: Rational  ) \n    defined at\n     src/TaylorN.jl:615   \n     ^ { T < :Integer } ( \n     a :: TaylorSeries.Taylor1{T} ,      n :: Integer  ) \n    defined at\n     src/Taylor1.jl:380   \n     ^ { T < :Number } ( \n     a :: TaylorSeries.Taylor1{T} ,      n :: Integer  ) \n    defined at\n     src/Taylor1.jl:372   \n     ^ ( \n     a :: TaylorSeries.HomogeneousPolynomial ,      n :: Integer  ) \n    defined at\n     src/TaylorN.jl:561   \n     ^ { T < :Integer } ( \n     a :: TaylorSeries.TaylorN{T} ,      n :: Integer  ) \n    defined at\n     src/TaylorN.jl:577   \n     ^ { T < :Number } ( \n     a :: TaylorSeries.TaylorN{T} ,      n :: Integer  ) \n    defined at\n     src/TaylorN.jl:569   \n     ^ ( \n     a :: TaylorSeries.Taylor1 ,      b :: TaylorSeries.Taylor1  ) \n    defined at\n     src/Taylor1.jl:416   \n     ^ ( \n     a :: TaylorSeries.TaylorN ,      b :: TaylorSeries.TaylorN  ) \n    defined at\n     src/TaylorN.jl:617   \n     ^ { S < :Real } ( \n     a :: TaylorSeries.Taylor1 ,      x :: S  ) \n    defined at\n     src/Taylor1.jl:420   \n     ^ { T < :Complex{T < :Real} } ( \n     a :: TaylorSeries.Taylor1 ,      x :: T  ) \n    defined at\n     src/Taylor1.jl:451   \n     ^ { S < :Real } ( \n     a :: TaylorSeries.TaylorN ,      x :: S  ) \n    defined at\n     src/TaylorN.jl:621   \n     ^ { T < :Complex{T < :Real} } ( \n     a :: TaylorSeries.TaylorN ,      x :: T  ) \n    defined at\n     src/TaylorN.jl:645    Hiding 46 methods defined outside of this package.  #  Base.sqrt     Function .  sqrt(a)  Return  the Taylor expansion of $\\sqrt(a)$, of order  a.order , for  a::Taylor1  polynomial. If the first non-vanishing coefficient of  a  is an odd power, and  ArgumentError  is thrown.  For details on making the Taylor expansion, see  TaylorSeries.sqrtHomogCoef .  source  Methods   \n     sqrt ( a :: TaylorSeries.Taylor1 ) \n    defined at\n     src/Taylor1.jl:539   \n     sqrt ( a :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:685    Hiding 12 methods defined outside of this package.  #  Base.exp     Function .  exp(a)  Return the Taylor expansion of $e^a$, of order  a.order , for  a::Taylor1  polynomial.  For details on making the Taylor expansion, see  TaylorSeries.expHomogCoef .  source  Methods   \n     exp ( a :: TaylorSeries.Taylor1 ) \n    defined at\n     src/Taylor1.jl:611   \n     exp ( a :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:716    Hiding 13 methods defined outside of this package.  #  Base.log     Function .  log(a)  Return the Taylor expansion of $\\log(a)$, of order  a.order , for  a::Taylor1  polynomial.  For details on making the Taylor expansion, see  TaylorSeries.logHomogCoef .  source  Methods   \n     log ( a :: TaylorSeries.Taylor1 ) \n    defined at\n     src/Taylor1.jl:656   \n     log ( a :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:735    Hiding 20 methods defined outside of this package.  #  Base.sin     Function .  sin(a)  Return the Taylor expansion of $\\sin(a)$, of order  a.order , for  a::Taylor1  polynomial.  For details on making the Taylor expansion, see  TaylorSeries.sincosHomogCoef .  source  Methods   \n     sin ( a :: TaylorSeries.Taylor1 ) \n    defined at\n     src/Taylor1.jl:703   \n     sin ( a :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:759    Hiding 12 methods defined outside of this package.  #  Base.cos     Function .  cos(a)  Return the Taylor expansion of $\\cos(a)$, of order  a.order , for  a::Taylor1  polynomial  For details on making the Taylor expansion, see  TaylorSeries.sincosHomogCoef ..  source  Methods   \n     cos ( a :: TaylorSeries.Taylor1 ) \n    defined at\n     src/Taylor1.jl:714   \n     cos ( a :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:760    Hiding 12 methods defined outside of this package.  #  Base.tan     Function .  tan(a)  Return the Taylor expansion of $\\tan(a)$, of order  a.order , for  a::Taylor1  polynomial.  For details on making the Taylor expansion, see  TaylorSeries.tanHomogCoef .  source  Methods   \n     tan ( a :: TaylorSeries.Taylor1 ) \n    defined at\n     src/Taylor1.jl:778   \n     tan ( a :: TaylorSeries.TaylorN ) \n    defined at\n     src/TaylorN.jl:788    Hiding 12 methods defined outside of this package.  #  Base.abs     Function .  abs(a)  Return  a  or  -a  depending on the 0-th order coefficient of the  Taylor1  polynomial  a . If  a.coeffs[1]  is zero, an  ArgumentError  is thrown.  source  abs(a::TaylorN)  Absolute value of a  TaylorN  polynomial, using the 0-th order coefficient.  Return  a  or  -a , depending on the 0-th order coefficient of  a . If it is zero, it throws an  ArgumentError .  source  Methods   \n     abs { T < :Real } ( a :: TaylorSeries.Taylor1{T} ) \n    defined at\n     src/Taylor1.jl:350   \n     abs { T < :Real } ( a :: TaylorSeries.TaylorN{T} ) \n    defined at\n     src/TaylorN.jl:548    Hiding 30 methods defined outside of this package.", 
            "title": "Functions and methods"
        }, 
        {
            "location": "/api/#internals", 
            "text": "#  TaylorSeries.generate_tables     Function .  generate_tables(num_vars, order)  Return the hash tables  coeff_table ,  index_table ,  size_table  and  pos_table . Internally, these are treated as  const .  Hash tables  coeff_table :: Array{Array{Array{Int64,1},1},1}  The $i+1$-th component contains a vector with the vectors of all the possible combinations of monomials of a  HomogeneousPolynomial  of order $i$.  index_table :: Array{Array{Int64,1},1}  The $i+1$-th component contains a vector of (hashed) indices that represent the distinct monomials of a  HomogeneousPolynomial  of order (degree) $i$.  size_table :: Array{Int64,1}  The $i+1$-th component contains the number of distinct monomials of the  HomogeneousPolynomial  of order $i$, equivalent to  length(coeff_table[i]) .  pos_table :: Array{Dict{Int64,Int64},1}  The $i+1$-th component maps the hash index to the (lexicographic) position of the corresponding monomial in  coeffs_table .  source  Methods   \n     generate_tables ( num_vars ,  order ) \n    defined at\n     src/hash_tables.jl:34    #  TaylorSeries.generate_index_vectors     Function .  generate_index_vectors(num_vars, degree)  Return a vector of index vectors with  num_vars  (number of variables) and degree.  source  Methods   \n     generate_index_vectors ( num_vars ,  degree ) \n    defined at\n     src/hash_tables.jl:51    #  TaylorSeries.in_base     Function .  in_base(order, v)  Convert vector  v  of non-negative integers to base  order+1 .  source  Methods   \n     in_base ( order ,  v ) \n    defined at\n     src/hash_tables.jl:90    #  TaylorSeries.make_inverse_dict     Function .  make_inverse_dict(v)  Return a Dict with the enumeration of  v : the elements of  v  point to the corresponding index.  It is used to construct  pos_table  from  index_table .  source  Methods   \n     make_inverse_dict ( v :: Array{T < :Any,1} ) \n    defined at\n     src/hash_tables.jl:81    #  TaylorSeries.order_posTb     Function .  order_posTb(order, nv, ord)  Return a vector with the positions, in a  HomogeneousPolynomial  of order  order , where the variable  nv  has order  ord .  source  Methods   \n     order_posTb ( \n     order :: Int64 ,      nv :: Int64 ,      ord :: Int64  ) \n    defined at\n     src/TaylorN.jl:1033    #  TaylorSeries.mul!     Function .  mul!(c, a, b)  Return  c = a*b  with no allocation; all parameters are  HomogeneousPolynomial .  source  mul!(c, a)  Return  c = a*a  with no allocation; all parameters are  HomogeneousPolynomial .  source  Methods   \n     mul! ( \n     c :: TaylorSeries.HomogeneousPolynomial ,      a :: TaylorSeries.HomogeneousPolynomial  ) \n    defined at\n     src/TaylorN.jl:462   \n     mul! ( \n     c :: TaylorSeries.HomogeneousPolynomial ,      a :: TaylorSeries.HomogeneousPolynomial ,      b :: TaylorSeries.HomogeneousPolynomial  ) \n    defined at\n     src/TaylorN.jl:428    #  TaylorSeries.mulHomogCoef     Function .  mulHomogCoef(kcoef, ac, bc)  Compute the  k -th expansion coefficient of $c = a\\cdot b$ given by   \\begin{equation*} c_k = \\sum_{j=0}^k a_j b_{k-j}, \\end{equation*}   with $a$ and $b$  Taylor1  polynomials.  Inputs are the  kcoef -th coefficient, and the vectors of the expansion coefficients  ac  and  bc , corresponding respectively to  a  and  b .  source  Methods   \n     mulHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      bc :: Array{T,1}  ) \n    defined at\n     src/Taylor1.jl:240    #  TaylorSeries.divHomogCoef     Function .  divHomogCoef(kcoef, ac, bc, coeffs, ordfact)  Compute the  k-th  expansion coefficient of $c = a / b$ given by   \\begin{equation*} c_k =  \\frac{1}{b_0} (a_k - \\sum_{j=0}^{k-1} c_j b_{k-j}), \\end{equation*}   with $a$ and $b$  Taylor1  polynomials.  Inputs are the  kcoef -th coefficient, the vectors of the expansion coefficients  ac  and  bc , corresponding respectively to  a  and  b , the already calculated expansion coefficients  coeffs  of  c , and  ordfact  which is the order of the factorized term of the denominator, whenever  b_0  is zero.  source  Methods   \n     divHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      bc :: Array{T,1} ,      coeffs :: Array{T,1} ,      ordfact :: Int64  ) \n    defined at\n     src/Taylor1.jl:318    #  TaylorSeries.powHomogCoef     Function .  powHomogCoef(kcoef, ac, x, coeffs, knull)  Compute the  k-th  expansion coefficient of $c = a^x$, given by   \\begin{equation*} c_k = \\frac{1}{k a_0} \\sum_{j=0}^{k-1} ((k-j)x -j) - j)a_{k-j} c_j, \\end{equation*}   with $a$ a  Taylor1  polynomial, and  x  a number.  Inputs are the  kcoef -th coefficient, the vector of the expansion coefficients  ac  of  a , the exponent  x , the already calculated expansion coefficients  coeffs  of  c , and  knull  which is the order of the first non-zero coefficient of  a .  source  Methods   \n     powHomogCoef { T < :Number ,  S < :Real } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      x :: S ,      coeffs :: Array{T,1} ,      knull :: Int64  ) \n    defined at\n     src/Taylor1.jl:473    #  TaylorSeries.squareHomogCoef     Function .  squareHomogCoef(kcoef, ac)  Compute the  k-th  expansion coefficient of $c = a^2$, given by   \\begin{eqnarray*} c_k &=& 2 \\sum_{j=0}^{(k-1)/2} a_{k-j} a_j, \\text{ if $k$ is odd, or }  \\\\\nc_k &=& 2 \\sum_{j=0}^{(k-2)/2} a_{k-j} a_j + (a_{k/2})^2, \\text{ if $k$ is even, } \\end{eqnarray*}   with $a$ a  Taylor1  polynomial.  Inputs are the  kcoef -th coefficient and the vector of the expansion coefficients  ac  of  a .  source  Methods   \n     squareHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1}  ) \n    defined at\n     src/Taylor1.jl:512    #  TaylorSeries.sqrtHomogCoef     Function .  sqrtHomogCoef(kcoef, ac, coeffs, knull)  Compute the  k-th  expansion coefficient of $c = \\sqrt(a)$, given by   \\begin{eqnarray*} c_k &=& \\frac{1}{2 c_0} ( a_k - 2\u00a0\\sum_{j=0}^{(k-1)/2} c_{k-j}c_j), \\text{ if $k$ is odd, or } \\\\\nc_k &=& \\frac{1}{2 c_0} ( a_k - 2 \\sum_{j=0}^{(k-2)/2} c_{k-j}c_j) - (c_{k/2})^2, \\text{ if $k$ is even,} \\end{eqnarray*}   with $a$ a  Taylor1  polynomial.  Inputs are the  kcoef -th coefficient, the vector of the expansion coefficients  ac  of  a , the already calculated expansion coefficients  coeffs  of  c , and  knull , which is half of the order of the first non-zero coefficient of  a .  source  Methods   \n     sqrtHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      coeffs :: Array{T,1} ,      knull :: Int64  ) \n    defined at\n     src/Taylor1.jl:583    #  TaylorSeries.expHomogCoef     Function .  expHomogCoef(kcoef, ac, coeffs)  Compute the  k-th  expansion coefficient of $c = \\exp(a)$ given by   \\begin{equation*} c_k = \\frac{1}{k} \\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j, \\end{equation*}   with $a$ a  Taylor1  polynomial.  Inputs are the  kcoef -th coefficient, the vector of the expansion coefficients  ac  of $a$, and the already calculated expansion coefficients  coeffs  of  c .  source  Methods   \n     expHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      coeffs :: Array{T,1}  ) \n    defined at\n     src/Taylor1.jl:638    #  TaylorSeries.logHomogCoef     Function .  logHomogCoef(kcoef, ac, coeffs)  Compute the  k-th  expansion coefficient of $c = \\log(a)$, given by   \\begin{equation*} c_k = \\frac{1}{a_0} (a_k - \\frac{1}{k} \\sum_{j=0}^{k-1} j a_{k-j} c_j ), \\end{equation*}   with $a$ a  Taylor1  polynomial.  Inputs are the  kcoef -th coefficient, the vector of the expansion coefficients  ac  of  a , and the already calculated expansion coefficients  coeffs  of  c .  source  Methods   \n     logHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      coeffs :: Array{T,1}  ) \n    defined at\n     src/Taylor1.jl:685    #  TaylorSeries.sincosHomogCoef     Function .  sincosHomogCoef(kcoef, ac, scoeffs, ccoeffs)  Compute the  k-th  expansion coefficient of $s = \\sin(a)$ and $c=\\cos(a)$ simultaneously given by   \\begin{eqnarray*} s_k &=& \\frac{1}{k} \\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j \\\\ \\\n c_k &=& -\\frac{1}{k}\\sum_{j=0}^{k-1} (k-j) a_{k-j} s_j \\end{eqnarray*}   with $a$ a  Taylor1  polynomial.  Inputs are the  kcoef -th coefficient, the vector of the expansion coefficients  ac  of  a , and the already calculated expansion coefficients  scoeffs  and  ccoeffs  of  sin(a)  and  cos(a) , respectvely.  source  Methods   \n     sincosHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      scoeffs :: Array{T,1} ,      ccoeffs :: Array{T,1}  ) \n    defined at\n     src/Taylor1.jl:753    #  TaylorSeries.tanHomogCoef     Function .  tanHomogCoef(kcoef, ac, coeffst2)  Compute the  k-th  expansion coefficient of $c = \\tan(a)$ given by   \\begin{equation*} c_k = a_k + \\frac{1}{k} \\sum_{j=0}^{k-1} (k-j) a_{k-j} p_j, \\end{equation*}   with $a$ a  Taylor1  polynomial and $p = c^2$.  Inputs are the  kcoef -th coefficient, the vector of the expansion coefficients  ac  of  a , and the already calculated expansion coefficients  coeffst2  of  c^2 .  source  Methods   \n     tanHomogCoef { T < :Number } ( \n     kcoef :: Int64 ,      ac :: Array{T,1} ,      coeffst2 :: Array{T,1}  ) \n    defined at\n     src/Taylor1.jl:809    #  Base.LinAlg.A_mul_B!     Function .  A_mul_B!(Y, A, B)  Multiply A*B and save the result in Y.  source  Methods   \n     A_mul_B! { T < :Number } ( \n     y :: Array{TaylorSeries.Taylor1{T},1} ,      a :: Union{Array{T,2},SparseMatrixCSC{T,Ti < :Integer}} ,      b :: Array{TaylorSeries.Taylor1{T},1}  ) \n    defined at\n     src/Taylor1.jl:905    Hiding 91 methods defined outside of this package.", 
            "title": "Internals"
        }
    ]
}