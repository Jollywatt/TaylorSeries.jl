<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>User guide - TaylorSeries.jl</title>

        <link href="../css/bootstrap-3.0.3.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">TaylorSeries.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Home</a>
                </li>
            
            
            
                <li >
                    <a href="../background/">Background</a>
                </li>
            
            
            
                <li class="active">
                    <a href="./">User guide</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../background/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li class="disabled">
                    <a rel="prev" >
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/lbenet/TaylorSeries.jl">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#user-guide">User guide</a></li>
        
            <li><a href="#one-variable">One variable</a></li>
        
            <li><a href="#many-variables">Many variables</a></li>
        
            <li><a href="#examples">Examples</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  MathJax.Hub.Config({
    TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "autoload-all.js"] }
  });
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

<h1 id="user-guide">User guide</h1>
<hr />
<p><code>TaylorSeries.jl</code> can be thought of as a polynomial algebraic manipulator in one or more
variables; these two cases are treated separately.  Three new types are defined,
<code>Taylor1</code>, <code>HomogeneousPolynomial</code> and <code>TaylorN</code>, which correspond to
expansions in one independent variable, homogeneous polynomials of various variables, and the polynomial
series in many independent variables, respectively. These types are subtypes
of <code>Number</code> and are defined parametrically.</p>
<p>The package is loaded as usual:</p>
<pre><code class="julia">julia&gt; using TaylorSeries
</code></pre>

<h2 id="one-variable">One variable</h2>
<p>Taylor expansions in one variable are represented by the <code>Taylor1</code> type, which
consists of a vector of coefficients (field <code>coeffs</code>) and the maximum
order considered for the expansion (field <code>order</code>). The
coefficients are arranged in ascending order with respect to the power of the
independent variable, so that
<code>coeffs[1]</code> is the constant term, <code>coeffs[2]</code> gives the first order term,
etc. This is a dense representation of the polynomial.
The order of the polynomial can be
omitted in the constructor, which is then fixed from the length of the
vector of coefficients; otherwise, the maximum
of the length of the vector of coefficients and the given integer is taken.</p>
<pre><code class="julia">julia&gt; Taylor1([1, 2, 3]) # Polynomial of order 2 with coefficients 1, 2, 3
 1 + 2⋅t + 3⋅t² + 𝒪(t³)

julia&gt; Taylor1([0.0, 1im]) # Also works with complex numbers
 ( 1.0 im )⋅t + 𝒪(t²)

julia&gt; affine(a) = a + taylor1_variable(typeof(a),5)  ## a + t of order 5
affine (generic function with 1 method)

julia&gt; t = affine(0.0) # Independent variable `t`
 1.0⋅t + 𝒪(t⁶)
</code></pre>

<p>Note that the information about the maximum order considered is displayed
using a big-O notation.</p>
<p>The definition of <code>affine(a)</code> uses the function <code>taylor1_variable</code>, which is a
shortcut to define the independent variable of a Taylor expansion,
with a given type and given order. As we show below, this is one of the
easiest ways to work with the package.</p>
<p>The usual arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>) have been
extended to work with the <code>Taylor1</code> type, including promotions that involve
<code>Number</code>s. The operations return a valid Taylor expansion with the same
maximum order; compare the last example below, where this is not possible:</p>
<pre><code class="julia">julia&gt; t*(3t+2.5)
 2.5⋅t + 3.0⋅t² + 𝒪(t⁶)

julia&gt; 1/(1-t)
 1.0 + 1.0⋅t + 1.0⋅t² + 1.0⋅t³ + 1.0⋅t⁴ + 1.0⋅t⁵ + 𝒪(t⁶)

julia&gt; t*(t^2-4)/(t+2)
 - 2.0⋅t + 1.0⋅t² + 𝒪(t⁶)

julia&gt; tI = im*t
 ( 1.0 im )⋅t + 𝒪(t⁶)

julia&gt; t^6  # order is 5
 0.0 + 𝒪(t⁶)

julia&gt; (1-t)^3.2
 1.0 - 3.2⋅t + 3.5200000000000005⋅t² - 1.4080000000000004⋅t³ + 0.07040000000000009⋅t⁴ + 0.011264000000000012⋅t⁵ + 𝒪(t⁶)

julia&gt; (1+t)^t
 1.0 + 1.0⋅t² - 0.5⋅t³ + 0.8333333333333333⋅t⁴ - 0.75⋅t⁵ + 𝒪(t⁶)

julia&gt; t^3.2
ERROR: The 0th order Taylor1 coefficient must be non-zero
to raise the Taylor1 polynomial to a non-integer exponent
 in ^ at /Users/benet/.julia/v0.3/TaylorSeries/src/utils_Taylor1.jl:280
</code></pre>

<p>Several elementary functions have been implemented; these compute their
coefficients recursively. So far, these functions are <code>exp</code>, <code>log</code>, <code>sqrt</code>, <code>sin</code>, <code>cos</code>
and <code>tan</code>;
more will be added in the future. Note that this way of obtaining the
Taylor coefficients is not the <em>laziest</em> way, in particular for many independent
variables. Yet, it is quite efficient, especially for the integration of
ordinary differential equations, which is among the applications we have in mind.</p>
<pre><code class="julia">julia&gt; exp(t)
 1.0 + 1.0⋅t + 0.5⋅t² + 0.16666666666666666⋅t³ + 0.041666666666666664⋅t⁴ + 0.008333333333333333⋅t⁵ + 𝒪(t⁶)

julia&gt; log(1-t)
 - 1.0⋅t - 0.5⋅t² - 0.3333333333333333⋅t³ - 0.25⋅t⁴ - 0.2⋅t⁵ + 𝒪(t⁶)

julia&gt; sqrt(t)
ERROR: First non-vanishing Taylor1 coefficient must correspond
to an **even power** in order to expand `sqrt` around 0
 in sqrt at /Users/benet/.julia/v0.3/TaylorSeries/src/utils_Taylor1.jl:351

julia&gt; sqrt(1 + t)
 1.0 + 0.5⋅t - 0.125⋅t² + 0.0625⋅t³ - 0.0390625⋅t⁴ + 0.02734375⋅t⁵ + 𝒪(t⁶)

julia&gt; imag(exp(tI)')
 - 1.0⋅t + 0.16666666666666666⋅t³ - 0.008333333333333333⋅t⁵ + 𝒪(t⁶)

julia&gt; real(exp(Taylor1([0.0,1im],17))) - cos(Taylor1([0.0,1.0],17)) == 0.0
true

julia&gt; convert(Taylor1{Rational{Int64}}, exp(t))  # output differes in v0.4
 1//1 + 1//1⋅t + 1//2⋅t² + 1//6⋅t³ + 1//24⋅t⁴ + 1//120⋅t⁵ + 𝒪(t⁶)
</code></pre>

<p>Differentiating and integrating is straightforward for polynomial expansions in
one variable. The last coefficient of a derivative is set to zero to keep the
same order as the original polynomial; for the integral, an
integration constant may be set to a different value (the default is zero). The
order of the resulting polynomial is not changed. The $n$-th ($n \ge 0$)
derivative is obtained using <code>deriv(a,n)</code>, where <code>a</code> is a Taylor series;
the default is $n=1$.</p>
<pre><code class="julia">julia&gt; diffTaylor(exp(t))
 1.0 + 1.0⋅t + 0.5⋅t² + 0.16666666666666666⋅t³ + 0.041666666666666664⋅t⁴ + 𝒪(t⁶)

julia&gt; integTaylor(exp(t))
 1.0⋅t + 0.5⋅t² + 0.16666666666666666⋅t³ + 0.041666666666666664⋅t⁴ + 0.008333333333333333⋅t⁵ + 𝒪(t⁶)

julia&gt; integTaylor( ans, 1.0)
 1.0 + 0.5⋅t² + 0.16666666666666666⋅t³ + 0.041666666666666664⋅t⁴ + 0.008333333333333333⋅t⁵ + 𝒪(t⁶)

julia&gt; integTaylor( diffTaylor( exp(-t)), 1.0 ) == exp(-t)
true

julia&gt; deriv( exp(affine(1.0))) == exp(1.0)
true

julia&gt; deriv( exp(affine(1.0)), 5) == exp(1.0) # Fifth derivative of `exp(1+t)`
true
</code></pre>

<p>To evaluate a Taylor series at a point, Horner's rule is used via the function
<code>evalTaylor(a::Taylor, dt::Number)</code>. Here, $dt$ is the increment from
the point $t_0$ where the Taylor expansion is calculated, i.e., the series
is evaluated at $t = t_0 + dt$. Omitting $dt$ corresponds to $dt = 0$.</p>
<pre><code class="julia">julia&gt; evaluate(exp(affine(1.0))) - e # exp(t) around t0=1 (order 5), evaluated there (dt=0)
0.0

julia&gt; evaluate(exp(t), 1) - e # exp(t) around t0=0 (order 5), evaluated at t=1
-0.0016151617923783057

julia&gt; evaluate( exp( taylor1_variable(17) ), 1) - e # exp(t) around t0=0 (order 17), evaluated at t=1
0.0

julia&gt; tBig = Taylor1([zero(BigFloat),one(BigFloat)],50) # With BigFloats
 1e+00⋅t + 𝒪(t⁵¹)

julia&gt; evaluate( exp(tBig), one(BigFloat) )
2.718281828459045235360287471352662497757247093699959574966967627723419298053556e+00 with 256 bits of precision

julia&gt; e - ans
6.573322999985292556154129119543257102601105719980995128942636339920549561322098e-67 with 256 bits of precision
</code></pre>

<h2 id="many-variables">Many variables</h2>
<p>A polynomial in $N&gt;1$ variables can be represented in (at least) two ways:
As a vector whose coefficients are homogeneous polynomials of fixed degree, or
as a vector whose coefficients are polynomials in $N-1$ variables. We have opted
to implement the first option, which seems to show better performance. An elegant
(lazy) implementation of the second representation was discussed on the
<a href="https://groups.google.com/forum/#!msg/julia-users/AkK_UdST3Ig/sNrtyRJHK0AJ">julia-users</a> list.</p>
<p><code>TaylorN</code> is thus constructed as a vector of parameterized homogeneous polynomials
defined by the type <code>HomogeneousPolynomial</code>, which in turn is a vector of
coefficients of given order (degree). This implementation imposes that the user
has to specify the (maximum) order and the number of independent
variables, which is done using the <code>set_variables(names)</code> function.
<code>names</code> is a string consisting of the desired <em>output</em> names of the variables,
separated by spaces. A vector of the resulting Taylor variables is returned:</p>
<pre><code class="julia">julia&gt; x, y = set_variables(&quot;x y&quot;)
2-element Array{TaylorN{Float64},1}:
  1.0 x + 𝒪(‖x‖⁷)
  1.0 y + 𝒪(‖x‖⁷)
</code></pre>

<p>The resulting objects are of <code>TaylorN{Float64}</code> type:</p>
<pre><code class="julia">julia&gt; x
 1.0 x + 𝒪(‖x‖⁷)

julia&gt; typeof(x)
TaylorN{Float64} (constructor with 1 method)

julia&gt; x.order
6

julia&gt; x.coeffs
7-element Array{HomogeneousPolynomial{Float64},1}:
    0.0
  1.0 x
    0.0
    0.0
    0.0
    0.0
    0.0
</code></pre>

<p>There is an optional <code>order</code> keyword argument for <code>set_variables</code>:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;x y&quot;, order=10)
2-element Array{TaylorN{Float64},1}:
  1.0 x + 𝒪(‖x‖¹¹)
  1.0 y + 𝒪(‖x‖¹¹)
</code></pre>

<p>Numbered variables are also available by specifying a single
variable name and the optional keyword argument <code>numvars</code>:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;α&quot;, numvars=3)
3-element Array{TaylorN{Float64},1}:
  1.0 α₁ + 𝒪(‖x‖⁷)
  1.0 α₂ + 𝒪(‖x‖⁷)
  1.0 α₃ + 𝒪(‖x‖⁷)
</code></pre>

<p>The function <code>show_params_TaylorN()</code> displays the current values of the
parameters:</p>
<pre><code class="julia">julia&gt; show_params_TaylorN()
INFO: Parameters for `TaylorN` and `HomogeneousPolynomial`:
Maximum order       = 6
Number of variables = 3
Variable names      = UTF8String[&quot;α₁&quot;,&quot;α₂&quot;,&quot;α₃&quot;]
</code></pre>

<p>Technically (internally), changing these parameters defines dictionaries that
translate the position of the coefficients of a <code>HomogeneousPolynomial</code>
into the corresponding
multi-variable monomials. Fixing these values from the start is imperative.</p>
<p>The easiest way to construct a <code>TaylorN</code> object is by defining symbols for
the independent variables, as above. Again, the Taylor expansions are implemented
around 0 for all variables; if the expansion
is needed around a different value, the trick is a simple translation of
the corresponding
independent variable $x \to x+a$.</p>
<p>Other ways of constructing <code>TaylorN</code> polynomials involve using <code>HomogeneousPolynomial</code>
objects directly, which is uncomfortable:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;x&quot;, numvars=2);

julia&gt; HomogeneousPolynomial([1,-1])
 1 x₁ - 1 x₂

julia&gt; TaylorN([HomogeneousPolynomial([1,0]), HomogeneousPolynomial([1,2,3])],4)
 1 x₁ + 1 x₁² + 2 x₁ x₂ + 3 x₂² + 𝒪(‖x‖⁵)
</code></pre>

<p>As before, the usual arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>)
have been extended to work with <code>TaylorN</code> objects, including the appropriate
promotions to deal with numbers. (Some of the arithmetic operations have
also been extended for
<code>HomogeneousPolynomial</code>, whenever the result is a <code>HomogeneousPolynomial</code>;
division, for instance, is not extended.) Also, the elementary functions have been
implemented, again by computing their coefficients recursively:</p>
<pre><code class="julia">julia&gt; x, y = set_variables(&quot;x&quot;, numvars=2, order=10);

julia&gt; exy = exp(x+y)
 1.0 + 1.0 x₁ + 1.0 x₂ + 0.5 x₁² + 1.0 x₁ x₂ + 0.5 x₂² + 0.16666666666666666 x₁³ + 0.5 x₁² x₂ + 0.5 x₁ x₂² + 0.16666666666666666 x₂³ + 0.041666666666666664 x₁⁴ + 0.16666666666666666 x₁³ x₂ + 0.25 x₁² x₂² + 0.16666666666666666 x₁ x₂³ + 0.041666666666666664 x₂⁴ + 0.008333333333333333 x₁⁵ + 0.041666666666666664 x₁⁴ x₂ + 0.08333333333333333 x₁³ x₂² + 0.08333333333333333 x₁² x₂³ + 0.041666666666666664 x₁ x₂⁴ + 0.008333333333333333 x₂⁵ + 0.0013888888888888887 x₁⁶ + 0.008333333333333331 x₁⁵ x₂ + 0.020833333333333332 x₁⁴ x₂² + 0.027777777777777776 x₁³ x₂³ + 0.020833333333333332 x₁² x₂⁴ + 0.008333333333333331 x₁ x₂⁵ + 0.0013888888888888887 x₂⁶ + 0.00019841269841269839 x₁⁷ + 0.0013888888888888885 x₁⁶ x₂ + 0.004166666666666666 x₁⁵ x₂² + 0.006944444444444443 x₁⁴ x₂³ + 0.006944444444444443 x₁³ x₂⁴ + 0.004166666666666666 x₁² x₂⁵ + 0.0013888888888888885 x₁ x₂⁶ + 0.00019841269841269839 x₂⁷ + 2.4801587301587298e-5 x₁⁸ + 0.00019841269841269836 x₁⁷ x₂ + 0.0006944444444444443 x₁⁶ x₂² + 0.0013888888888888887 x₁⁵ x₂³ + 0.0017361111111111108 x₁⁴ x₂⁴ + 0.0013888888888888887 x₁³ x₂⁵ + 0.0006944444444444443 x₁² x₂⁶ + 0.00019841269841269836 x₁ x₂⁷ + 2.4801587301587298e-5 x₂⁸ + 2.7557319223985884e-6 x₁⁹ + 2.4801587301587295e-5 x₁⁸ x₂ + 9.920634920634918e-5 x₁⁷ x₂² + 0.0002314814814814814 x₁⁶ x₂³ + 0.0003472222222222221 x₁⁵ x₂⁴ + 0.0003472222222222221 x₁⁴ x₂⁵ + 0.0002314814814814814 x₁³ x₂⁶ + 9.920634920634918e-5 x₁² x₂⁷ + 2.4801587301587295e-5 x₁ x₂⁸ + 2.7557319223985884e-6 x₂⁹ + 2.7557319223985883e-7 x₁¹⁰ + 2.7557319223985884e-6 x₁⁹ x₂ + 1.2400793650793647e-5 x₁⁸ x₂² + 3.306878306878306e-5 x₁⁷ x₂³ + 5.787037037037036e-5 x₁⁶ x₂⁴ + 6.944444444444443e-5 x₁⁵ x₂⁵ + 5.787037037037036e-5 x₁⁴ x₂⁶ + 3.306878306878306e-5 x₁³ x₂⁷ + 1.2400793650793647e-5 x₁² x₂⁸ + 2.7557319223985884e-6 x₁ x₂⁹ + 2.7557319223985883e-7 x₂¹⁰ + 𝒪(‖x‖¹¹)
</code></pre>

<p>The function <code>get_coeff(a,v)</code>
gives the coefficient of <code>x</code> that corresponds to the monomial
specified by the vector of powers <code>v</code>:</p>
<pre><code class="julia">julia&gt; get_coeff(exy, [3,5]) == 1/720
false

julia&gt; rationalize(get_coeff(exy, [3,5]))
1//720
</code></pre>

<p>Partial differentiation is also implemented for
<code>TaylorN</code> objects,
using <code>diffTaylor</code>; integration is yet to be implemented.</p>
<pre><code class="julia">julia&gt; f(x,y) = x^3 + 2x^2 * y - 7x + 2
f (generic function with 1 method)

julia&gt; g(x,y) = y - x^4
g (generic function with 1 method)

julia&gt; diffTaylor( f(x,y), 1 )   # partial derivative with respect to 1st variable
 - 7.0 + 3.0 x₁² + 4.0 x₁ x₂ + 𝒪(‖x‖¹¹)

julia&gt; diffTaylor( g(x,y), 2 )
 1.0 + 𝒪(‖x‖¹¹)

julia&gt; diffTaylor( g(x,y), 3 )   # error, since we are dealing with 2 variables
ERROR: assertion failed: 1 &lt;= r &lt;= _params_taylorN.numVars
 in diffTaylor at /Users/benet/.julia/v0.3/TaylorSeries/src/utils_TaylorN.jl:681
 in diffTaylor at /Users/benet/.julia/v0.3/TaylorSeries/src/utils_TaylorN.jl:711
</code></pre>

<p><code>evaluate</code> can also be used for <code>TaylorN</code> objects, using it on vectors of
numbers (<code>Real</code> or <code>Complex</code>); the length of the vector must coincide with the number
of independent variables.</p>
<pre><code class="julia">julia&gt; evaluate(exy, [.1,.02]) == e^0.12
true
</code></pre>

<p>Functions to compute the gradient, Jacobian and
Hessian have also been implemented. Using the
functions $f(x,y) = x^3 + 2x^2 y - 7 x + 2$ and $g(x,y) = y-x^4$ defined above,
we may use <code>∇</code> (<code>\nabla+TAB</code>) or <code>TaylorSeries.gradient</code>; the results are of
type <code>Array{TaylorN{T},1}</code>. To compute the Jacobian or Hessian of a vector field
evaluated at a point, we use <code>jacobian</code> and <code>hessian</code>:</p>
<pre><code class="julia">julia&gt; f1 = f(x,y)
 2.0 - 7.0 x₁ + 1.0 x₁³ + 2.0 x₁² x₂ + 𝒪(‖x‖¹¹)

julia&gt; g1 = g(x,y)
 1.0 x₂ - 1.0 x₁⁴ + 𝒪(‖x‖¹¹)

julia&gt; ∇(f1)
2-element Array{TaylorN{Float64},1}:
  - 7.0 + 3.0 x₁² + 4.0 x₁ x₂ + 𝒪(‖x‖¹¹)
                      2.0 x₁² + 𝒪(‖x‖¹¹)

julia&gt; gradient( g1 )
2-element Array{TaylorN{Float64},1}:
  - 4.0 x₁³ + 𝒪(‖x‖¹¹)
        1.0 + 𝒪(‖x‖¹¹)

julia&gt; jacobian([f1,g1], [2,1])
2x2 Array{Float64,2}:
  13.0  8.0
 -32.0  1.0

julia&gt; fg = f1-g1-2*f1*g1
 2.0 - 7.0 x₁ - 5.0 x₂ + 14.0 x₁ x₂ + 1.0 x₁³ + 2.0 x₁² x₂ + 5.0 x₁⁴ - 2.0 x₁³ x₂ - 4.0 x₁² x₂² - 14.0 x₁⁵ + 2.0 x₁⁷ + 4.0 x₁⁶ x₂ + 𝒪(‖x‖¹¹)

julia&gt; hessian(ans) # hessian at zero
2x2 Array{Float64,2}:
  0.0  14.0
 14.0   0.0

 julia&gt; fg1 = f(x+1.0,y+1.0)-g(x+1.0,y+1.0)-2*f(x+1.0,y+1.0)*g(x+1.0,y+1.0)
  - 2.0 - 12.0 x₁ + 5.0 x₂ - 13.0 x₁² + 20.0 x₁ x₂ - 4.0 x₂² + 29.0 x₁³ + 48.0 x₁² x₂ - 8.0 x₁ x₂² + 65.0 x₁⁴ + 78.0 x₁³ x₂ - 4.0 x₁² x₂² + 52.0 x₁⁵ + 60.0 x₁⁴ x₂ + 18.0 x₁⁶ + 24.0 x₁⁵ x₂ + 2.0 x₁⁷ + 4.0 x₁⁶ x₂ + 𝒪(‖x‖¹¹)

julia&gt; hessian(fg, [1.0,1.0])
2x2 Array{Float64,2}:
 -26.0  20.0
  20.0  -8.0

julia&gt; ans == hessian(fg1)
true
</code></pre>

<h2 id="examples">Examples</h2>
<h3 id="1-four-square-identity">1. Four-square identity</h3>
<p>The first example described below, shows that the four-square identity holds:
\begin{eqnarray}
(a_1+a_2+a_3+a_4)\cdot(b_1+b_2+b_3+b_4) &amp; = &amp;
     (a_1 b_1 - a_2 b_2 - a_3 b_3 -a_4 b_4)^2 + \qquad \nonumber \\
\label{eq:Euler}
  &amp; &amp; (a_1 b_2 - a_2 b_1 - a_3 b_4 -a_4 b_3)^2 + \\
  &amp; &amp; (a_1 b_3 - a_2 b_4 - a_3 b_1 -a_4 b_2)^2 + \nonumber \\
  &amp; &amp; (a_1 b_4 - a_2 b_3 - a_3 b_2 -a_4 b_1)^2, \nonumber
\end{eqnarray}
as proved by Euler. The code can we found in one of the tests of the package.</p>
<p>First, we reset the maximum degree of the polynomial to 4, since the RHS
of the equation
has <em>a priori</em> terms of fourth order, and the number of independent variables to
8.</p>
<pre><code class="julia">julia&gt; # Define the variables α₁, ..., α₄, β₁, ..., β₄
       make_variable(name, index::Int) = string(name, TaylorSeries.subscriptify(index))
make_variable (generic function with 1 method)

julia&gt; variable_names = [make_variable(&quot;α&quot;, i) for i in 1:4]
4-element Array{UTF8String,1}:
 &quot;α₁&quot;
 &quot;α₂&quot;
 &quot;α₃&quot;
 &quot;α₄&quot;

julia&gt; append!(variable_names, [make_variable(&quot;β&quot;, i) for i in 1:4])
8-element Array{UTF8String,1}:
 &quot;α₁&quot;
 &quot;α₂&quot;
 &quot;α₃&quot;
 &quot;α₄&quot;
 &quot;β₁&quot;
 &quot;β₂&quot;
 &quot;β₃&quot;
 &quot;β₄&quot;

julia&gt; # Create the Taylor objects (order 4, numvars=8)
       a1, a2, a3, a4, b1, b2, b3, b4 = set_variables(variable_names, order=4);

julia&gt; a1
1.0 α₁ + 𝒪(‖x‖⁵)

julia&gt; b1
 1.0 β₁ + 𝒪(‖x‖⁵)
</code></pre>

<p>Now we define the terms that appear in (\ref{eq:Euler}):</p>
<pre><code class="julia">julia&gt; lhs1 = a1^2 + a2^2 + a3^2 + a4^2 ;

julia&gt; lhs2 = b1^2 + b2^2 + b3^2 + b4^2 ;

julia&gt; rhs1 = (a1*b1 - a2*b2 - a3*b3 - a4*b4)^2 ;

julia&gt; rhs2 = (a1*b2 + a2*b1 + a3*b4 - a4*b3)^2 ;

julia&gt; rhs3 = (a1*b3 - a2*b4 + a3*b1 + a4*b2)^2 ;

julia&gt; rhs4 = (a1*b4 + a2*b3 - a3*b2 + a4*b1)^2 ;
</code></pre>

<p>Finally, we check that the LHS is indeed equal to the RHS:</p>
<pre><code class="julia">julia&gt; lhs = lhs1 * lhs2
 1.0 α₁² β₁² + 1.0 α₂² β₁² + 1.0 α₃² β₁² + 1.0 α₄² β₁² + 1.0 α₁² β₂² + 1.0 α₂² β₂² + 1.0 α₃² β₂² + 1.0 α₄² β₂² + 1.0 α₁² β₃² + 1.0 α₂² β₃² + 1.0 α₃² β₃² + 1.0 α₄² β₃² + 1.0 α₁² β₄² + 1.0 α₂² β₄² + 1.0 α₃² β₄² + 1.0 α₄² β₄² + 𝒪(‖x‖⁵)

julia&gt; rhs = rhs1 + rhs2 + rhs3 + rhs4
 1.0 α₁² β₁² + 1.0 α₂² β₁² + 1.0 α₃² β₁² + 1.0 α₄² β₁² + 1.0 α₁² β₂² + 1.0 α₂² β₂² + 1.0 α₃² β₂² + 1.0 α₄² β₂² + 1.0 α₁² β₃² + 1.0 α₂² β₃² + 1.0 α₃² β₃² + 1.0 α₄² β₃² + 1.0 α₁² β₄² + 1.0 α₂² β₄² + 1.0 α₃² β₄² + 1.0 α₄² β₄² + 𝒪(‖x‖⁵)

julia&gt; lhs == rhs
true
</code></pre>

<p>The identity is thus satisfied. $\square$.</p>
<h3 id="2-fatemans-test">2. Fateman's test</h3>
<p>Richard J. Fateman, from Berkley, proposed as a stringent test
of polynomial multiplication
the evaluation of $s*(s+1)$, where $s = (1+x+y+z+w)^{20}$. This is
implemented in
the function <code>fateman1</code>. We shall also evaluate the form $s^2+s$ in <code>fateman2</code>,
which involves fewer operations (and makes a fairer comparison to what
Mathematica does). Below we use Julia v0.4, since it is faster than v0.3.</p>
<pre><code class="julia">julia&gt; # change number of variables and maxOrder
       set_variables(&quot;x&quot;, numvars=4, order=40);

julia&gt; function fateman1(degree::Int)
          T = Int128
          oneH = HomogeneousPolynomial(one(T), 0)
          # s = 1 + x + y + z + w
          s = TaylorN( [oneH, HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)], degree )
          s = s^degree  
          # s is converted to order 2*ndeg
          s = TaylorN(s, 2*degree)

          s * ( s+TaylorN(oneH, 2*degree) )
      end
fateman1 (generic function with 1 method)

julia&gt; @time f1 = fateman1(0);
elapsed time: 0.193653166 seconds (8318304 bytes allocated)

julia&gt; @time f1 = fateman1(20);
</code></pre>

<p>The last instruction shows that we indeed need <code>Int128</code> arithmetic.</p>
<pre><code class="julia">julia&gt; function fateman2(degree::Int)
           T = Int128
           oneH = HomogeneousPolynomial(one(T), 0)
           s = TaylorN( [oneH, HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)], degree )
           s = s^degree
           # s is converted to order 2*ndeg
           s = TaylorN(s, 2*degree)
           return s^2 + s
       end
fateman2 (generic function with 1 method)

julia&gt; @time f2 = fateman2(0);
elapsed time: 0.004246911 seconds (151832 bytes allocated)

julia&gt; @time f2 = fateman2(20);
elapsed time: 8.260762578 seconds (1412298112 bytes allocated, 18.28% gc time)

julia&gt; get_coeff(f2,[1,6,7,20])
128358585324486316800

julia&gt; sum(TaylorSeries.sizeTable) # number of distinct monomials
135751
</code></pre>

<p>The tests above show the necessity of using integers of type <code>Int128</code>, that
<code>fateman2</code> is about twice as fast as <code>fateman1</code>, and that the series has 135751
monomials on 4 variables.</p>
<p>We mention that our implementation of <code>fateman2</code> (in julia v0.4) is roughly
1.5 times slower than Mathematica.</p></div>
        </div>

	<footer class="col-md-12">
		<hr>
		
		<center>Copyright &copy; 2014, 2015, Luis Benet and David P. Sanders</center>
		
		<center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
	</footer>


        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>